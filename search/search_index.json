{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blog REST API Service This is a REST API build using the FAST API framework. It has the purpose to to provide the capabilities to manage the articles, posts and skills in the database. Development Please follow the following steps to start developing on this project: Clone this repository You need to to have the following requirements installed: Poetry Python 3.9+ Create a new virtual environment and install the dependencies using the following command: poetry install Testing To run the test, run the following command pytest Documentation The documentation is automatically generated using MKDocs in combination with several plugins. Therefor, you are not required to add new pages in the mkdocs.yml file. You can find the documentation here . If you want to access the documentation locally use the following command: poetry mkdocs serve","title":"Introduction"},{"location":"#blog-rest-api-service","text":"This is a REST API build using the FAST API framework. It has the purpose to to provide the capabilities to manage the articles, posts and skills in the database.","title":"Blog REST API Service"},{"location":"#development","text":"Please follow the following steps to start developing on this project: Clone this repository You need to to have the following requirements installed: Poetry Python 3.9+ Create a new virtual environment and install the dependencies using the following command: poetry install","title":"Development"},{"location":"#testing","text":"To run the test, run the following command pytest","title":"Testing"},{"location":"#documentation","text":"The documentation is automatically generated using MKDocs in combination with several plugins. Therefor, you are not required to add new pages in the mkdocs.yml file. You can find the documentation here . If you want to access the documentation locally use the following command: poetry mkdocs serve","title":"Documentation"},{"location":"changelog/","text":"","title":"Changelog"},{"location":"license/","text":"","title":"License"},{"location":"reference/SUMMARY/","text":"config settings db base base_models init_db main models article_model project_model skill_model user_model routers api v1 articles_route auth_route projects_route skills_route user_route schemas articles_schema auth_schema projects_schema skills_schema tags_schema token_schema user_schema services articles_service auth_service projects_service skills_service token_service user_service util jwt_authentication","title":"SUMMARY"},{"location":"reference/main/","text":"Initializes the App with the provided configurations and middlewares.","title":"main"},{"location":"reference/config/","text":"This folder contains all configuration related scripts.","title":"config"},{"location":"reference/config/settings/","text":"Reads and provides the environment variables as a dict. Settings Bases: BaseSettings Reads all the environment variables. Source code in src/config/settings.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class Settings ( BaseSettings ): \"\"\"Reads all the environment variables.\"\"\" # API base configuration API_PATH : str = \"/api/v1\" API_NAME : str = \"Blog-RestAPI-service\" API_DESC : str = \"This API can be used to store new articles posts and skills for the blog frontend\" # API contact configuration API_CONTACT_NAME : str API_CONTACT_MAIL : EmailStr API_CONTACT_SITE : str # Postgres configuration POSTGRES_SERVER : str POSTGRES_USER : str POSTGRES_PW : str POSTGRES_DB : str SQLALCHEMY_DATABASE_URI : Optional [ PostgresDsn ] = None @validator ( \"SQLALCHEMY_DATABASE_URI\" , pre = True ) def assemble_db_connection ( cls , v : Optional [ str ], values : Dict [ str , Any ]) -> str : \"\"\"Assemble the SQL connection. This function is being executed as soon as the class is initialized. Args: v (Optional[str]): The already assembled value. values (Dict[str, Any]): The dictionary containing the loaded environment variables. Returns: str: The assembled PostgreSQL connection. \"\"\" if isinstance ( v , str ): return v return PostgresDsn . build ( # type: ignore[no-any-return] scheme = \"postgresql+asyncpg\" , user = values . get ( \"POSTGRES_USER\" ), password = values . get ( \"POSTGRES_PW\" ), host = values . get ( \"POSTGRES_SERVER\" ), path = f \"/ { values . get ( 'POSTGRES_DB' ) or '' } \" , ) # JWT Settings JWT_SECRET_KEY : str JWT_REFRESH_SECRET_KEY : str ALGORITHM : str ACCESS_TOKEN_EXPIRE_MINUTES : int REFRESH_TOKEN_EXPIRE_MINUTES : int # API Admin user configuration ADMIN_USER : EmailStr ADMIN_PW : str # Sentry settings SENTRY_DSN : str class Config ( BaseSettings . Config ): \"\"\"Set the settings.\"\"\" env_file = \".env\" # type: ignore[assignment] case_sensitive = True Config Bases: BaseSettings . Config Set the settings. Source code in src/config/settings.py 72 73 74 75 76 class Config ( BaseSettings . Config ): \"\"\"Set the settings.\"\"\" env_file = \".env\" # type: ignore[assignment] case_sensitive = True assemble_db_connection ( v , values ) Assemble the SQL connection. This function is being executed as soon as the class is initialized. Parameters: Name Type Description Default v Optional [ str ] The already assembled value. required values Dict [ str , Any ] The dictionary containing the loaded environment variables. required Returns: Name Type Description str str The assembled PostgreSQL connection. Source code in src/config/settings.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @validator ( \"SQLALCHEMY_DATABASE_URI\" , pre = True ) def assemble_db_connection ( cls , v : Optional [ str ], values : Dict [ str , Any ]) -> str : \"\"\"Assemble the SQL connection. This function is being executed as soon as the class is initialized. Args: v (Optional[str]): The already assembled value. values (Dict[str, Any]): The dictionary containing the loaded environment variables. Returns: str: The assembled PostgreSQL connection. \"\"\" if isinstance ( v , str ): return v return PostgresDsn . build ( # type: ignore[no-any-return] scheme = \"postgresql+asyncpg\" , user = values . get ( \"POSTGRES_USER\" ), password = values . get ( \"POSTGRES_PW\" ), host = values . get ( \"POSTGRES_SERVER\" ), path = f \"/ { values . get ( 'POSTGRES_DB' ) or '' } \" , )","title":"settings"},{"location":"reference/config/settings/#src.config.settings.Settings","text":"Bases: BaseSettings Reads all the environment variables. Source code in src/config/settings.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class Settings ( BaseSettings ): \"\"\"Reads all the environment variables.\"\"\" # API base configuration API_PATH : str = \"/api/v1\" API_NAME : str = \"Blog-RestAPI-service\" API_DESC : str = \"This API can be used to store new articles posts and skills for the blog frontend\" # API contact configuration API_CONTACT_NAME : str API_CONTACT_MAIL : EmailStr API_CONTACT_SITE : str # Postgres configuration POSTGRES_SERVER : str POSTGRES_USER : str POSTGRES_PW : str POSTGRES_DB : str SQLALCHEMY_DATABASE_URI : Optional [ PostgresDsn ] = None @validator ( \"SQLALCHEMY_DATABASE_URI\" , pre = True ) def assemble_db_connection ( cls , v : Optional [ str ], values : Dict [ str , Any ]) -> str : \"\"\"Assemble the SQL connection. This function is being executed as soon as the class is initialized. Args: v (Optional[str]): The already assembled value. values (Dict[str, Any]): The dictionary containing the loaded environment variables. Returns: str: The assembled PostgreSQL connection. \"\"\" if isinstance ( v , str ): return v return PostgresDsn . build ( # type: ignore[no-any-return] scheme = \"postgresql+asyncpg\" , user = values . get ( \"POSTGRES_USER\" ), password = values . get ( \"POSTGRES_PW\" ), host = values . get ( \"POSTGRES_SERVER\" ), path = f \"/ { values . get ( 'POSTGRES_DB' ) or '' } \" , ) # JWT Settings JWT_SECRET_KEY : str JWT_REFRESH_SECRET_KEY : str ALGORITHM : str ACCESS_TOKEN_EXPIRE_MINUTES : int REFRESH_TOKEN_EXPIRE_MINUTES : int # API Admin user configuration ADMIN_USER : EmailStr ADMIN_PW : str # Sentry settings SENTRY_DSN : str class Config ( BaseSettings . Config ): \"\"\"Set the settings.\"\"\" env_file = \".env\" # type: ignore[assignment] case_sensitive = True","title":"Settings"},{"location":"reference/config/settings/#src.config.settings.Settings.Config","text":"Bases: BaseSettings . Config Set the settings. Source code in src/config/settings.py 72 73 74 75 76 class Config ( BaseSettings . Config ): \"\"\"Set the settings.\"\"\" env_file = \".env\" # type: ignore[assignment] case_sensitive = True","title":"Config"},{"location":"reference/config/settings/#src.config.settings.Settings.assemble_db_connection","text":"Assemble the SQL connection. This function is being executed as soon as the class is initialized. Parameters: Name Type Description Default v Optional [ str ] The already assembled value. required values Dict [ str , Any ] The dictionary containing the loaded environment variables. required Returns: Name Type Description str str The assembled PostgreSQL connection. Source code in src/config/settings.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @validator ( \"SQLALCHEMY_DATABASE_URI\" , pre = True ) def assemble_db_connection ( cls , v : Optional [ str ], values : Dict [ str , Any ]) -> str : \"\"\"Assemble the SQL connection. This function is being executed as soon as the class is initialized. Args: v (Optional[str]): The already assembled value. values (Dict[str, Any]): The dictionary containing the loaded environment variables. Returns: str: The assembled PostgreSQL connection. \"\"\" if isinstance ( v , str ): return v return PostgresDsn . build ( # type: ignore[no-any-return] scheme = \"postgresql+asyncpg\" , user = values . get ( \"POSTGRES_USER\" ), password = values . get ( \"POSTGRES_PW\" ), host = values . get ( \"POSTGRES_SERVER\" ), path = f \"/ { values . get ( 'POSTGRES_DB' ) or '' } \" , )","title":"assemble_db_connection()"},{"location":"reference/db/","text":"This folder contains all scripts that are required to interact with the underlying database.","title":"db"},{"location":"reference/db/base/","text":"Base settings for interacting with the database. get_session () async Session generator. Provides a new session that allows, to conduct CRUD actions on the database. Yields: Type Description AsyncSession Iterator[AsyncSession]: The session instance to use for conducting operations Source code in src/db/base.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 async def get_session () -> AsyncSession : \"\"\"Session generator. Provides a new session that allows, to conduct CRUD actions on the database. Yields: Iterator[AsyncSession]: The session instance to use for conducting operations \"\"\" session : AsyncSession = None try : async with async_session () as session : yield session except BaseException : if session is not None : await session . rollback () raise finally : if session is not None : await session . close ()","title":"base"},{"location":"reference/db/base/#src.db.base.get_session","text":"Session generator. Provides a new session that allows, to conduct CRUD actions on the database. Yields: Type Description AsyncSession Iterator[AsyncSession]: The session instance to use for conducting operations Source code in src/db/base.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 async def get_session () -> AsyncSession : \"\"\"Session generator. Provides a new session that allows, to conduct CRUD actions on the database. Yields: Iterator[AsyncSession]: The session instance to use for conducting operations \"\"\" session : AsyncSession = None try : async with async_session () as session : yield session except BaseException : if session is not None : await session . rollback () raise finally : if session is not None : await session . close ()","title":"get_session()"},{"location":"reference/db/base_models/","text":"Import all the models for alembic.","title":"base_models"},{"location":"reference/db/init_db/","text":"Initializes the admin user in the DB if not already done. main () async Create admin user in the database. Checks, whether the admin user is already available in the database and if not, creates it. Source code in src/db/init_db.py 13 14 15 16 17 18 19 20 21 22 23 async def main () -> None : \"\"\"Create admin user in the database. Checks, whether the admin user is already available in the database and if not, creates it. \"\"\" async with async_session () as session : session = cast ( AsyncSession , session ) res : Union [ UserDB , None ] = await user_service . get_user ( session , settings . ADMIN_USER ) if res is None : await user_service . create_new_user ( session , settings . ADMIN_USER , settings . ADMIN_PW )","title":"init_db"},{"location":"reference/db/init_db/#src.db.init_db.main","text":"Create admin user in the database. Checks, whether the admin user is already available in the database and if not, creates it. Source code in src/db/init_db.py 13 14 15 16 17 18 19 20 21 22 23 async def main () -> None : \"\"\"Create admin user in the database. Checks, whether the admin user is already available in the database and if not, creates it. \"\"\" async with async_session () as session : session = cast ( AsyncSession , session ) res : Union [ UserDB , None ] = await user_service . get_user ( session , settings . ADMIN_USER ) if res is None : await user_service . create_new_user ( session , settings . ADMIN_USER , settings . ADMIN_PW )","title":"main()"},{"location":"reference/models/","text":"All models representing the required tables in the database.","title":"models"},{"location":"reference/models/article_model/","text":"Article model for the database. Article Bases: Base Represents the article table in the database. Source code in src/models/article_model.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Article ( Base ): \"\"\"Represents the article table in the database.\"\"\" __tablename__ = \"articles\" id = Column ( Integer , primary_key = True , index = True ) title = Column ( String ) author = Column ( String , index = True ) image_url = Column ( String ) description = Column ( String ) content = Column ( String ) tags = Column ( JSONB ) created_at = Column ( DATE , nullable = False ) updated_at = Column ( DATE )","title":"article_model"},{"location":"reference/models/article_model/#src.models.article_model.Article","text":"Bases: Base Represents the article table in the database. Source code in src/models/article_model.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Article ( Base ): \"\"\"Represents the article table in the database.\"\"\" __tablename__ = \"articles\" id = Column ( Integer , primary_key = True , index = True ) title = Column ( String ) author = Column ( String , index = True ) image_url = Column ( String ) description = Column ( String ) content = Column ( String ) tags = Column ( JSONB ) created_at = Column ( DATE , nullable = False ) updated_at = Column ( DATE )","title":"Article"},{"location":"reference/models/project_model/","text":"Project model for the database. Project Bases: Base Represents the projects table in the database. Source code in src/models/project_model.py 8 9 10 11 12 13 14 15 16 17 18 class Project ( Base ): \"\"\"Represents the projects table in the database.\"\"\" __tablename__ = \"projects\" id = Column ( Integer , primary_key = True , index = True ) title = Column ( String ) image_url = Column ( String ) description = Column ( String ) project_url = Column ( String ) tags = Column ( JSONB )","title":"project_model"},{"location":"reference/models/project_model/#src.models.project_model.Project","text":"Bases: Base Represents the projects table in the database. Source code in src/models/project_model.py 8 9 10 11 12 13 14 15 16 17 18 class Project ( Base ): \"\"\"Represents the projects table in the database.\"\"\" __tablename__ = \"projects\" id = Column ( Integer , primary_key = True , index = True ) title = Column ( String ) image_url = Column ( String ) description = Column ( String ) project_url = Column ( String ) tags = Column ( JSONB )","title":"Project"},{"location":"reference/models/skill_model/","text":"User model for the database. Skill Bases: Base Represents the categories table in the database. Source code in src/models/skill_model.py 7 8 9 10 11 12 13 14 15 class Skill ( Base ): \"\"\"Represents the categories table in the database.\"\"\" __tablename__ = \"skills\" id = Column ( Integer , primary_key = True , index = True ) name = Column ( String , index = True ) category = Column ( String ) experience = Column ( Integer )","title":"skill_model"},{"location":"reference/models/skill_model/#src.models.skill_model.Skill","text":"Bases: Base Represents the categories table in the database. Source code in src/models/skill_model.py 7 8 9 10 11 12 13 14 15 class Skill ( Base ): \"\"\"Represents the categories table in the database.\"\"\" __tablename__ = \"skills\" id = Column ( Integer , primary_key = True , index = True ) name = Column ( String , index = True ) category = Column ( String ) experience = Column ( Integer )","title":"Skill"},{"location":"reference/models/user_model/","text":"User model for the database. User Bases: Base Represents the user table in the database. Source code in src/models/user_model.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class User ( Base ): \"\"\"Represents the user table in the database.\"\"\" __tablename__ = \"users\" id = Column ( Integer , primary_key = True , index = True ) email = Column ( String , index = True ) password = Column ( String ) @property def hash_password ( self ) -> None : \"\"\"Init the property. Raises: AttributeError: Raised, in case no password provided. \"\"\" raise AttributeError ( \"Missing_password\" ) @hash_password . setter def hash_password ( self , hash_password : str ) -> None : \"\"\"Hash the password. The setter function for the ```property```. Ensures, that the password is hashed before being assigned to the property. Args: hash_password (str): The password to hash. \"\"\" self . password = bcrypt . hashpw ( hash_password . encode ( \"utf-8\" ), bcrypt . gensalt ()) . decode ( \"utf-8\" ) def verify_password ( self , password : str ) -> bool : \"\"\"Verify the password. Verifies, whether the provided password matches the password stored for the current user. Args: password (str): The password to verify. Returns: bool: The flag indicating, whether the password is valid. \"\"\" self_encoded_password : bytes = self . password . encode ( \"utf-8\" ) self_password_hash : bytes = bcrypt . hashpw ( password . encode ( \"utf-8\" ), self_encoded_password ) return hmac . compare_digest ( self_encoded_password , self_password_hash ) hash_password () property writable Init the property. Raises: Type Description AttributeError Raised, in case no password provided. Source code in src/models/user_model.py 19 20 21 22 23 24 25 26 @property def hash_password ( self ) -> None : \"\"\"Init the property. Raises: AttributeError: Raised, in case no password provided. \"\"\" raise AttributeError ( \"Missing_password\" ) verify_password ( password ) Verify the password. Verifies, whether the provided password matches the password stored for the current user. Parameters: Name Type Description Default password str The password to verify. required Returns: Name Type Description bool bool The flag indicating, whether the password is valid. Source code in src/models/user_model.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def verify_password ( self , password : str ) -> bool : \"\"\"Verify the password. Verifies, whether the provided password matches the password stored for the current user. Args: password (str): The password to verify. Returns: bool: The flag indicating, whether the password is valid. \"\"\" self_encoded_password : bytes = self . password . encode ( \"utf-8\" ) self_password_hash : bytes = bcrypt . hashpw ( password . encode ( \"utf-8\" ), self_encoded_password ) return hmac . compare_digest ( self_encoded_password , self_password_hash )","title":"user_model"},{"location":"reference/models/user_model/#src.models.user_model.User","text":"Bases: Base Represents the user table in the database. Source code in src/models/user_model.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class User ( Base ): \"\"\"Represents the user table in the database.\"\"\" __tablename__ = \"users\" id = Column ( Integer , primary_key = True , index = True ) email = Column ( String , index = True ) password = Column ( String ) @property def hash_password ( self ) -> None : \"\"\"Init the property. Raises: AttributeError: Raised, in case no password provided. \"\"\" raise AttributeError ( \"Missing_password\" ) @hash_password . setter def hash_password ( self , hash_password : str ) -> None : \"\"\"Hash the password. The setter function for the ```property```. Ensures, that the password is hashed before being assigned to the property. Args: hash_password (str): The password to hash. \"\"\" self . password = bcrypt . hashpw ( hash_password . encode ( \"utf-8\" ), bcrypt . gensalt ()) . decode ( \"utf-8\" ) def verify_password ( self , password : str ) -> bool : \"\"\"Verify the password. Verifies, whether the provided password matches the password stored for the current user. Args: password (str): The password to verify. Returns: bool: The flag indicating, whether the password is valid. \"\"\" self_encoded_password : bytes = self . password . encode ( \"utf-8\" ) self_password_hash : bytes = bcrypt . hashpw ( password . encode ( \"utf-8\" ), self_encoded_password ) return hmac . compare_digest ( self_encoded_password , self_password_hash )","title":"User"},{"location":"reference/models/user_model/#src.models.user_model.User.hash_password","text":"Init the property. Raises: Type Description AttributeError Raised, in case no password provided. Source code in src/models/user_model.py 19 20 21 22 23 24 25 26 @property def hash_password ( self ) -> None : \"\"\"Init the property. Raises: AttributeError: Raised, in case no password provided. \"\"\" raise AttributeError ( \"Missing_password\" )","title":"hash_password()"},{"location":"reference/models/user_model/#src.models.user_model.User.verify_password","text":"Verify the password. Verifies, whether the provided password matches the password stored for the current user. Parameters: Name Type Description Default password str The password to verify. required Returns: Name Type Description bool bool The flag indicating, whether the password is valid. Source code in src/models/user_model.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def verify_password ( self , password : str ) -> bool : \"\"\"Verify the password. Verifies, whether the provided password matches the password stored for the current user. Args: password (str): The password to verify. Returns: bool: The flag indicating, whether the password is valid. \"\"\" self_encoded_password : bytes = self . password . encode ( \"utf-8\" ) self_password_hash : bytes = bcrypt . hashpw ( password . encode ( \"utf-8\" ), self_encoded_password ) return hmac . compare_digest ( self_encoded_password , self_password_hash )","title":"verify_password()"},{"location":"reference/routers/","text":"This folder contains all the endpoints for the API.","title":"routers"},{"location":"reference/routers/api/","text":"Provides a new router instance, containing all the endpoints available.","title":"api"},{"location":"reference/routers/v1/","text":"This folder contains all V1 endpoints.","title":"v1"},{"location":"reference/routers/v1/articles_route/","text":"All article related endpoints. add_article ( article , db_session = Depends ( get_session )) async Endpoint to create a new article in the database. Parameters: Name Type Description Default article CreateArticle The article to create. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Type Description ArticleCreated Union[ArticleCreated, None]: The information about the created article. Source code in src/routers/v1/articles_route.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @router . post ( \"/\" , summary = \"Create a new article\" , description = \"Creates a new article with the information provided\" , status_code = status . HTTP_201_CREATED , response_model = ArticleCreated , ) async def add_article ( article : CreateArticle , db_session : AsyncSession = Depends ( get_session ) ) -> ArticleCreated : \"\"\"Endpoint to create a new article in the database. Args: article (CreateArticle): The article to create. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: Union[ArticleCreated, None]: The information about the created article. \"\"\" article = await articles_service . create_article ( article , db_session ) return article delete_article ( article_id = Path ( description = 'The ID of the article to delete.' ), db_session = Depends ( get_session )) async Endpoint for deleting an article in the database. Parameters: Name Type Description Default article_id int The article to delete from the database. Path(description='The ID of the article to delete.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description ArticleDeleted ArticleDeleted The status indicating the result of the deletion. Source code in src/routers/v1/articles_route.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 @router . delete ( \"/ {article_id} \" , summary = \"Delete the specified article\" , description = \"Deletes the specified article in the database\" , status_code = status . HTTP_200_OK , response_model = ArticleDeleted , ) async def delete_article ( article_id : int = Path ( description = \"The ID of the article to delete.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> ArticleDeleted : \"\"\"Endpoint for deleting an article in the database. Args: article_id (int): The article to delete from the database. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: ArticleDeleted: The status indicating the result of the deletion. \"\"\" response = await articles_service . delete_article ( article_id , db_session ) return response get_article ( article_id = Path ( description = 'The ID of the article to obtain.' ), db_session = Depends ( get_session )) async Endpoint for obtaining the specified article from the database. Parameters: Name Type Description Default article_id int The ID of the article to obtain. Path(description='The ID of the article to obtain.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description ArticleDB ArticleDB The obtained article or nothing, in case nothing matches the ID. Source code in src/routers/v1/articles_route.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @router . get ( \"/ {article_id} \" , summary = \"Get the specified article\" , description = \"Get the specified article from the database\" , status_code = status . HTTP_200_OK , response_model = ArticleDB , ) async def get_article ( article_id : int = Path ( description = \"The ID of the article to obtain.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> ArticleDB : \"\"\"Endpoint for obtaining the specified article from the database. Args: article_id (int, optional): The ID of the article to obtain. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: ArticleDB: The obtained article or nothing, in case nothing matches the ID. \"\"\" article = await articles_service . get_article ( article_id , db_session ) return article get_articles ( db_session = Depends ( get_session ), skip = Query ( default = 0 , description = 'The number of items to skip in the article table' ), limit = Query ( default = 100 , description = 'The maximum number to return from the article table' )) async Endpoint for obtaining all the articles in the database. Parameters: Name Type Description Default db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) skip int The number of items to skip. Defaults to 0. Query(default=0, description='The number of items to skip in the article table') limit int The maximum number of items to return. Defaults to 100. Query(default=100, description='The maximum number to return from the article table') Returns: Type Description Union [ List [ ArticleDB ], None] List[ArticleDB]: The list of articles obtained from the DB. Source code in src/routers/v1/articles_route.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @router . get ( \"/\" , summary = \"Get all articles\" , description = \"Get all articles stored in the database\" , status_code = status . HTTP_200_OK , response_model = List [ ArticleDB ], ) async def get_articles ( db_session : AsyncSession = Depends ( get_session ), skip : int = Query ( default = 0 , description = \"The number of items to skip in the article table\" ), limit : int = Query ( default = 100 , description = \"The maximum number to return from the article table\" ), ) -> Union [ List [ ArticleDB ], None ]: \"\"\"Endpoint for obtaining all the articles in the database. Args: db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. skip (int, optional): The number of items to skip. Defaults to 0. limit (int, optional): The maximum number of items to return. Defaults to 100. Returns: List[ArticleDB]: The list of articles obtained from the DB. \"\"\" articles = await articles_service . get_articles ( skip , limit , db_session ) return articles # type: ignore[no-any-return] update_article ( article , article_id = Path ( description = 'The ID of the article to update.' ), db_session = Depends ( get_session )) async Endpoint to update an article in the database. Parameters: Name Type Description Default article UpdateArticle The information to update on the specified article. required article_id int The id of the article to update. Path(description='The ID of the article to update.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description UpdateArticle UpdateArticle The status of the update. Source code in src/routers/v1/articles_route.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 @router . put ( \"/ {article_id} \" , summary = \"Updates an article\" , description = \"Updated the specified article with the information provided\" , status_code = status . HTTP_200_OK , response_model = ArticleUpdated , ) async def update_article ( article : UpdateArticle , article_id : int = Path ( description = \"The ID of the article to update.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> UpdateArticle : \"\"\"Endpoint to update an article in the database. Args: article (UpdateArticle): The information to update on the specified article. article_id (int): The id of the article to update. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: UpdateArticle: The status of the update. \"\"\" article = await articles_service . update_article ( article_id , article , db_session ) return article","title":"articles_route"},{"location":"reference/routers/v1/articles_route/#src.routers.v1.articles_route.add_article","text":"Endpoint to create a new article in the database. Parameters: Name Type Description Default article CreateArticle The article to create. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Type Description ArticleCreated Union[ArticleCreated, None]: The information about the created article. Source code in src/routers/v1/articles_route.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @router . post ( \"/\" , summary = \"Create a new article\" , description = \"Creates a new article with the information provided\" , status_code = status . HTTP_201_CREATED , response_model = ArticleCreated , ) async def add_article ( article : CreateArticle , db_session : AsyncSession = Depends ( get_session ) ) -> ArticleCreated : \"\"\"Endpoint to create a new article in the database. Args: article (CreateArticle): The article to create. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: Union[ArticleCreated, None]: The information about the created article. \"\"\" article = await articles_service . create_article ( article , db_session ) return article","title":"add_article()"},{"location":"reference/routers/v1/articles_route/#src.routers.v1.articles_route.delete_article","text":"Endpoint for deleting an article in the database. Parameters: Name Type Description Default article_id int The article to delete from the database. Path(description='The ID of the article to delete.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description ArticleDeleted ArticleDeleted The status indicating the result of the deletion. Source code in src/routers/v1/articles_route.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 @router . delete ( \"/ {article_id} \" , summary = \"Delete the specified article\" , description = \"Deletes the specified article in the database\" , status_code = status . HTTP_200_OK , response_model = ArticleDeleted , ) async def delete_article ( article_id : int = Path ( description = \"The ID of the article to delete.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> ArticleDeleted : \"\"\"Endpoint for deleting an article in the database. Args: article_id (int): The article to delete from the database. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: ArticleDeleted: The status indicating the result of the deletion. \"\"\" response = await articles_service . delete_article ( article_id , db_session ) return response","title":"delete_article()"},{"location":"reference/routers/v1/articles_route/#src.routers.v1.articles_route.get_article","text":"Endpoint for obtaining the specified article from the database. Parameters: Name Type Description Default article_id int The ID of the article to obtain. Path(description='The ID of the article to obtain.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description ArticleDB ArticleDB The obtained article or nothing, in case nothing matches the ID. Source code in src/routers/v1/articles_route.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @router . get ( \"/ {article_id} \" , summary = \"Get the specified article\" , description = \"Get the specified article from the database\" , status_code = status . HTTP_200_OK , response_model = ArticleDB , ) async def get_article ( article_id : int = Path ( description = \"The ID of the article to obtain.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> ArticleDB : \"\"\"Endpoint for obtaining the specified article from the database. Args: article_id (int, optional): The ID of the article to obtain. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: ArticleDB: The obtained article or nothing, in case nothing matches the ID. \"\"\" article = await articles_service . get_article ( article_id , db_session ) return article","title":"get_article()"},{"location":"reference/routers/v1/articles_route/#src.routers.v1.articles_route.get_articles","text":"Endpoint for obtaining all the articles in the database. Parameters: Name Type Description Default db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) skip int The number of items to skip. Defaults to 0. Query(default=0, description='The number of items to skip in the article table') limit int The maximum number of items to return. Defaults to 100. Query(default=100, description='The maximum number to return from the article table') Returns: Type Description Union [ List [ ArticleDB ], None] List[ArticleDB]: The list of articles obtained from the DB. Source code in src/routers/v1/articles_route.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @router . get ( \"/\" , summary = \"Get all articles\" , description = \"Get all articles stored in the database\" , status_code = status . HTTP_200_OK , response_model = List [ ArticleDB ], ) async def get_articles ( db_session : AsyncSession = Depends ( get_session ), skip : int = Query ( default = 0 , description = \"The number of items to skip in the article table\" ), limit : int = Query ( default = 100 , description = \"The maximum number to return from the article table\" ), ) -> Union [ List [ ArticleDB ], None ]: \"\"\"Endpoint for obtaining all the articles in the database. Args: db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. skip (int, optional): The number of items to skip. Defaults to 0. limit (int, optional): The maximum number of items to return. Defaults to 100. Returns: List[ArticleDB]: The list of articles obtained from the DB. \"\"\" articles = await articles_service . get_articles ( skip , limit , db_session ) return articles # type: ignore[no-any-return]","title":"get_articles()"},{"location":"reference/routers/v1/articles_route/#src.routers.v1.articles_route.update_article","text":"Endpoint to update an article in the database. Parameters: Name Type Description Default article UpdateArticle The information to update on the specified article. required article_id int The id of the article to update. Path(description='The ID of the article to update.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description UpdateArticle UpdateArticle The status of the update. Source code in src/routers/v1/articles_route.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 @router . put ( \"/ {article_id} \" , summary = \"Updates an article\" , description = \"Updated the specified article with the information provided\" , status_code = status . HTTP_200_OK , response_model = ArticleUpdated , ) async def update_article ( article : UpdateArticle , article_id : int = Path ( description = \"The ID of the article to update.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> UpdateArticle : \"\"\"Endpoint to update an article in the database. Args: article (UpdateArticle): The information to update on the specified article. article_id (int): The id of the article to update. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: UpdateArticle: The status of the update. \"\"\" article = await articles_service . update_article ( article_id , article , db_session ) return article","title":"update_article()"},{"location":"reference/routers/v1/auth_route/","text":"All authentication related endpoints. authentication ( auth_data , db_session = Depends ( get_session )) async Endpoint for conducting the authentication. Parameters: Name Type Description Default auth_data AuthSchema JSON that contains the mail address and password of the user. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description AuthTokenSchema AuthTokenSchema The new issued access and refresh tokens Source code in src/routers/v1/auth_route.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @router . post ( \"/login\" , summary = \"Conduct the authentication\" , description = \"Provide your email and password to obtain a token that can be used for secured endpoints.\" , status_code = status . HTTP_200_OK , response_model = AuthTokenSchema , ) async def authentication ( auth_data : AuthSchema , db_session : AsyncSession = Depends ( get_session ), ) -> AuthTokenSchema : \"\"\"Endpoint for conducting the authentication. Args: auth_data (AuthSchema): JSON that contains the mail address and password of the user. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: AuthTokenSchema: The new issued access and refresh tokens \"\"\" auth_tokens = await auth_service . authenticate_user ( auth_data . email , auth_data . password , db_session ) return auth_tokens refresh_token ( refresh_token ) async Endpoint to obtain a new access token based on a valid refresh token. Parameters: Name Type Description Default refresh_token RefreshSchema The refresh token to validated required Returns: Name Type Description AuthTokenSchema AuthTokenSchema The new issued access and refresh tokens Source code in src/routers/v1/auth_route.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @router . post ( \"/refresh\" , summary = \"Refresh a token\" , description = \"Provide your refresh token to receive a new authentication token\" , status_code = status . HTTP_200_OK , response_model = AuthTokenSchema , ) async def refresh_token ( refresh_token : RefreshSchema , ) -> AuthTokenSchema : \"\"\"Endpoint to obtain a new access token based on a valid refresh token. Args: refresh_token (RefreshSchema): The refresh token to validated Returns: AuthTokenSchema: The new issued access and refresh tokens \"\"\" auth_tokens = await auth_service . refresh_token ( refresh_token . refresh_token ) return auth_tokens","title":"auth_route"},{"location":"reference/routers/v1/auth_route/#src.routers.v1.auth_route.authentication","text":"Endpoint for conducting the authentication. Parameters: Name Type Description Default auth_data AuthSchema JSON that contains the mail address and password of the user. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description AuthTokenSchema AuthTokenSchema The new issued access and refresh tokens Source code in src/routers/v1/auth_route.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @router . post ( \"/login\" , summary = \"Conduct the authentication\" , description = \"Provide your email and password to obtain a token that can be used for secured endpoints.\" , status_code = status . HTTP_200_OK , response_model = AuthTokenSchema , ) async def authentication ( auth_data : AuthSchema , db_session : AsyncSession = Depends ( get_session ), ) -> AuthTokenSchema : \"\"\"Endpoint for conducting the authentication. Args: auth_data (AuthSchema): JSON that contains the mail address and password of the user. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: AuthTokenSchema: The new issued access and refresh tokens \"\"\" auth_tokens = await auth_service . authenticate_user ( auth_data . email , auth_data . password , db_session ) return auth_tokens","title":"authentication()"},{"location":"reference/routers/v1/auth_route/#src.routers.v1.auth_route.refresh_token","text":"Endpoint to obtain a new access token based on a valid refresh token. Parameters: Name Type Description Default refresh_token RefreshSchema The refresh token to validated required Returns: Name Type Description AuthTokenSchema AuthTokenSchema The new issued access and refresh tokens Source code in src/routers/v1/auth_route.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @router . post ( \"/refresh\" , summary = \"Refresh a token\" , description = \"Provide your refresh token to receive a new authentication token\" , status_code = status . HTTP_200_OK , response_model = AuthTokenSchema , ) async def refresh_token ( refresh_token : RefreshSchema , ) -> AuthTokenSchema : \"\"\"Endpoint to obtain a new access token based on a valid refresh token. Args: refresh_token (RefreshSchema): The refresh token to validated Returns: AuthTokenSchema: The new issued access and refresh tokens \"\"\" auth_tokens = await auth_service . refresh_token ( refresh_token . refresh_token ) return auth_tokens","title":"refresh_token()"},{"location":"reference/routers/v1/projects_route/","text":"All projects related endpoints. add_project ( project , db_session = Depends ( get_session )) async Endpoint to create a new project in the database. Parameters: Name Type Description Default project CreateProject The project to create. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description ProjectCreated ProjectCreated The information about the created project. Source code in src/routers/v1/projects_route.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @router . post ( \"/\" , summary = \"Create a new project\" , description = \"Creates a new project with the information provided\" , status_code = status . HTTP_201_CREATED , response_model = ProjectCreated , ) async def add_project ( project : Project , db_session : AsyncSession = Depends ( get_session )) -> ProjectCreated : \"\"\"Endpoint to create a new project in the database. Args: project (CreateProject): The project to create. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: ProjectCreated: The information about the created project. \"\"\" project = await projects_service . create_project ( project , db_session ) return project delete_project ( project_id = Path ( description = 'The ID of the project to delete.' ), db_session = Depends ( get_session )) async Endpoint for deleting a project in the database. Parameters: Name Type Description Default project_id int The project to delete from the database. Path(description='The ID of the project to delete.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description ProjectDeleted ProjectDeleted The status indicating the result of the deletion. Source code in src/routers/v1/projects_route.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @router . delete ( \"/ {project_id} \" , summary = \"Delete the specified project\" , description = \"Deletes the specified project in the database\" , status_code = status . HTTP_200_OK , response_model = ProjectDeleted , ) async def delete_project ( project_id : int = Path ( description = \"The ID of the project to delete.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> ProjectDeleted : \"\"\"Endpoint for deleting a project in the database. Args: project_id (int): The project to delete from the database. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: ProjectDeleted: The status indicating the result of the deletion. \"\"\" response = await projects_service . delete_project ( project_id , db_session ) return response get_project ( project_id = Path ( description = 'The ID of the project to obtain.' ), db_session = Depends ( get_session )) async Endpoint for obtaining the specified project from the database. Parameters: Name Type Description Default project_id int The ID of the project to obtain. Path(description='The ID of the project to obtain.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description ProjectDB ProjectDB The obtained project or nothing, in case nothing matches the ID. Source code in src/routers/v1/projects_route.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @router . get ( \"/ {project_id} \" , summary = \"Get the specified project\" , description = \"Get the specified project from the database\" , status_code = status . HTTP_200_OK , response_model = ProjectDB , ) async def get_project ( project_id : int = Path ( description = \"The ID of the project to obtain.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> ProjectDB : \"\"\"Endpoint for obtaining the specified project from the database. Args: project_id (int, optional): The ID of the project to obtain. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: ProjectDB: The obtained project or nothing, in case nothing matches the ID. \"\"\" project = await projects_service . get_project ( project_id , db_session ) return project get_projects ( db_session = Depends ( get_session ), skip = Query ( default = 0 , description = 'The number of items to skip in the project table' ), limit = Query ( default = 100 , description = 'The maximum number to return from the project table' )) async Endpoint to obtain all projects in the database. Parameters: Name Type Description Default db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) skip int The number of items to skip. Defaults to 0. Query(default=0, description='The number of items to skip in the project table') limit int The maximum number of items to return. Defaults to 100. Query(default=100, description='The maximum number to return from the project table') Returns: Type Description List [ ProjectDB ] List[ProjectDB]: The list of articles obtained from the DB. Source code in src/routers/v1/projects_route.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @router . get ( \"/\" , summary = \"Get all articles\" , description = \"Get all articles stored in the database\" , status_code = status . HTTP_200_OK , response_model = List [ ProjectDB ], ) async def get_projects ( db_session : AsyncSession = Depends ( get_session ), skip : int = Query ( default = 0 , description = \"The number of items to skip in the project table\" ), limit : int = Query ( default = 100 , description = \"The maximum number to return from the project table\" ), ) -> List [ ProjectDB ]: \"\"\"Endpoint to obtain all projects in the database. Args: db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. skip (int, optional): The number of items to skip. Defaults to 0. limit (int, optional): The maximum number of items to return. Defaults to 100. Returns: List[ProjectDB]: The list of articles obtained from the DB. \"\"\" projects = await projects_service . get_projects ( skip , limit , db_session ) return projects # type: ignore[no-any-return] update_project ( project , project_id = Path ( description = 'The ID of the project to update.' ), db_session = Depends ( get_session )) async Endpoint to update a project in the database. Parameters: Name Type Description Default project UpdateProject The information to update on the specified project. required project_id int The id of the project to update. Path(description='The ID of the project to update.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description UpdateProject ProjectUpdated The status of the update. Source code in src/routers/v1/projects_route.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @router . put ( \"/ {project_id} \" , summary = \"Updates an project\" , description = \"Updated the specified project with the information provided\" , status_code = status . HTTP_200_OK , response_model = ProjectUpdated , ) async def update_project ( project : UpdateProject , project_id : int = Path ( description = \"The ID of the project to update.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> ProjectUpdated : \"\"\"Endpoint to update a project in the database. Args: project (UpdateProject): The information to update on the specified project. project_id (int): The id of the project to update. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: UpdateProject: The status of the update. \"\"\" project = await projects_service . update_project ( project_id , project , db_session ) return project","title":"projects_route"},{"location":"reference/routers/v1/projects_route/#src.routers.v1.projects_route.add_project","text":"Endpoint to create a new project in the database. Parameters: Name Type Description Default project CreateProject The project to create. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description ProjectCreated ProjectCreated The information about the created project. Source code in src/routers/v1/projects_route.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @router . post ( \"/\" , summary = \"Create a new project\" , description = \"Creates a new project with the information provided\" , status_code = status . HTTP_201_CREATED , response_model = ProjectCreated , ) async def add_project ( project : Project , db_session : AsyncSession = Depends ( get_session )) -> ProjectCreated : \"\"\"Endpoint to create a new project in the database. Args: project (CreateProject): The project to create. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: ProjectCreated: The information about the created project. \"\"\" project = await projects_service . create_project ( project , db_session ) return project","title":"add_project()"},{"location":"reference/routers/v1/projects_route/#src.routers.v1.projects_route.delete_project","text":"Endpoint for deleting a project in the database. Parameters: Name Type Description Default project_id int The project to delete from the database. Path(description='The ID of the project to delete.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description ProjectDeleted ProjectDeleted The status indicating the result of the deletion. Source code in src/routers/v1/projects_route.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 @router . delete ( \"/ {project_id} \" , summary = \"Delete the specified project\" , description = \"Deletes the specified project in the database\" , status_code = status . HTTP_200_OK , response_model = ProjectDeleted , ) async def delete_project ( project_id : int = Path ( description = \"The ID of the project to delete.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> ProjectDeleted : \"\"\"Endpoint for deleting a project in the database. Args: project_id (int): The project to delete from the database. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: ProjectDeleted: The status indicating the result of the deletion. \"\"\" response = await projects_service . delete_project ( project_id , db_session ) return response","title":"delete_project()"},{"location":"reference/routers/v1/projects_route/#src.routers.v1.projects_route.get_project","text":"Endpoint for obtaining the specified project from the database. Parameters: Name Type Description Default project_id int The ID of the project to obtain. Path(description='The ID of the project to obtain.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description ProjectDB ProjectDB The obtained project or nothing, in case nothing matches the ID. Source code in src/routers/v1/projects_route.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 @router . get ( \"/ {project_id} \" , summary = \"Get the specified project\" , description = \"Get the specified project from the database\" , status_code = status . HTTP_200_OK , response_model = ProjectDB , ) async def get_project ( project_id : int = Path ( description = \"The ID of the project to obtain.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> ProjectDB : \"\"\"Endpoint for obtaining the specified project from the database. Args: project_id (int, optional): The ID of the project to obtain. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: ProjectDB: The obtained project or nothing, in case nothing matches the ID. \"\"\" project = await projects_service . get_project ( project_id , db_session ) return project","title":"get_project()"},{"location":"reference/routers/v1/projects_route/#src.routers.v1.projects_route.get_projects","text":"Endpoint to obtain all projects in the database. Parameters: Name Type Description Default db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) skip int The number of items to skip. Defaults to 0. Query(default=0, description='The number of items to skip in the project table') limit int The maximum number of items to return. Defaults to 100. Query(default=100, description='The maximum number to return from the project table') Returns: Type Description List [ ProjectDB ] List[ProjectDB]: The list of articles obtained from the DB. Source code in src/routers/v1/projects_route.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @router . get ( \"/\" , summary = \"Get all articles\" , description = \"Get all articles stored in the database\" , status_code = status . HTTP_200_OK , response_model = List [ ProjectDB ], ) async def get_projects ( db_session : AsyncSession = Depends ( get_session ), skip : int = Query ( default = 0 , description = \"The number of items to skip in the project table\" ), limit : int = Query ( default = 100 , description = \"The maximum number to return from the project table\" ), ) -> List [ ProjectDB ]: \"\"\"Endpoint to obtain all projects in the database. Args: db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. skip (int, optional): The number of items to skip. Defaults to 0. limit (int, optional): The maximum number of items to return. Defaults to 100. Returns: List[ProjectDB]: The list of articles obtained from the DB. \"\"\" projects = await projects_service . get_projects ( skip , limit , db_session ) return projects # type: ignore[no-any-return]","title":"get_projects()"},{"location":"reference/routers/v1/projects_route/#src.routers.v1.projects_route.update_project","text":"Endpoint to update a project in the database. Parameters: Name Type Description Default project UpdateProject The information to update on the specified project. required project_id int The id of the project to update. Path(description='The ID of the project to update.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description UpdateProject ProjectUpdated The status of the update. Source code in src/routers/v1/projects_route.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 @router . put ( \"/ {project_id} \" , summary = \"Updates an project\" , description = \"Updated the specified project with the information provided\" , status_code = status . HTTP_200_OK , response_model = ProjectUpdated , ) async def update_project ( project : UpdateProject , project_id : int = Path ( description = \"The ID of the project to update.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> ProjectUpdated : \"\"\"Endpoint to update a project in the database. Args: project (UpdateProject): The information to update on the specified project. project_id (int): The id of the project to update. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: UpdateProject: The status of the update. \"\"\" project = await projects_service . update_project ( project_id , project , db_session ) return project","title":"update_project()"},{"location":"reference/routers/v1/skills_route/","text":"All skill related endpoints. add_skill ( skill , db_session = Depends ( get_session )) async Endpoint to create a new skill in the database. Parameters: Name Type Description Default skill SkillSchema The skill to create. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description SkillDB SkillDB The information about the created skill. Source code in src/routers/v1/skills_route.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @router . post ( \"/\" , summary = \"Create a new skill\" , description = \"Creates a new skill with the information provided\" , status_code = status . HTTP_201_CREATED , response_model = SkillDB , ) async def add_skill ( skill : SkillSchema , db_session : AsyncSession = Depends ( get_session )) -> SkillDB : \"\"\"Endpoint to create a new skill in the database. Args: skill (SkillSchema): The skill to create. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: SkillDB: The information about the created skill. \"\"\" skill = await skills_service . create_skill ( skill , db_session ) return skill delete_skill ( skill_id = Path ( description = 'The ID of the skill to delete.' ), db_session = Depends ( get_session )) async Endpoint for deleting an skill in the database. Parameters: Name Type Description Default skill_id int The skill to delete from the database. Path(description='The ID of the skill to delete.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description SkillDeleted SkillAdjusted The status indicating the result of the deletion. Source code in src/routers/v1/skills_route.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 @router . delete ( \"/ {skill_id} \" , summary = \"Delete the specified skill\" , description = \"Deletes the specified skill in the database\" , status_code = status . HTTP_200_OK , response_model = SkillAdjusted , ) async def delete_skill ( skill_id : int = Path ( description = \"The ID of the skill to delete.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> SkillAdjusted : \"\"\"Endpoint for deleting an skill in the database. Args: skill_id (int): The skill to delete from the database. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: SkillDeleted: The status indicating the result of the deletion. \"\"\" response = await skills_service . delete_skill ( skill_id , db_session ) return response get_skill ( skill_id = Path ( description = 'The ID of the skill to obtain.' ), db_session = Depends ( get_session )) async Endpoint for obtaining the specified skill from the database. Parameters: Name Type Description Default skill_id int The ID of the skill to obtain. Path(description='The ID of the skill to obtain.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description SkillDB SkillDB The obtained skill or nothing, in case nothing matches the ID. Source code in src/routers/v1/skills_route.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @router . get ( \"/ {skill_id} \" , summary = \"Get the specified skill\" , description = \"Get the specified skill from the database\" , status_code = status . HTTP_200_OK , response_model = SkillDB , ) async def get_skill ( skill_id : int = Path ( description = \"The ID of the skill to obtain.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> SkillDB : \"\"\"Endpoint for obtaining the specified skill from the database. Args: skill_id (int): The ID of the skill to obtain. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: SkillDB: The obtained skill or nothing, in case nothing matches the ID. \"\"\" skill = await skills_service . get_skill ( skill_id , db_session ) return skill get_skills ( db_session = Depends ( get_session ), skip = Query ( default = 0 , description = 'The number of items to skip in the skill table' ), limit = Query ( default = 100 , description = 'The maximum number to return from the skill table' )) async Endpoint for obtaining all the skills in the database. Parameters: Name Type Description Default db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) skip int The number of items to skip. Defaults to 0. Query(default=0, description='The number of items to skip in the skill table') limit int The maximum number of items to return. Defaults to 100. Query(default=100, description='The maximum number to return from the skill table') Returns: Type Description Union [ List [ SkillDB ], None] List[SkillDB]: The list of skills obtained from the DB. Source code in src/routers/v1/skills_route.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @router . get ( \"/\" , summary = \"Get all skills\" , description = \"Get all skills stored in the database\" , status_code = status . HTTP_200_OK , response_model = List [ SkillDB ], ) async def get_skills ( db_session : AsyncSession = Depends ( get_session ), skip : int = Query ( default = 0 , description = \"The number of items to skip in the skill table\" ), limit : int = Query ( default = 100 , description = \"The maximum number to return from the skill table\" ), ) -> Union [ List [ SkillDB ], None ]: \"\"\"Endpoint for obtaining all the skills in the database. Args: db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. skip (int, optional): The number of items to skip. Defaults to 0. limit (int, optional): The maximum number of items to return. Defaults to 100. Returns: List[SkillDB]: The list of skills obtained from the DB. \"\"\" skills = await skills_service . get_skills ( skip , limit , db_session ) return skills # type: ignore[no-any-return] update_skill ( skill , skill_id = Path ( description = 'The ID of the skill to update.' ), db_session = Depends ( get_session )) async Endpoint to update an skill in the database. Parameters: Name Type Description Default skill UpdateSkill The information to update on the specified skill. required skill_id int The id of the skill to update. Path(description='The ID of the skill to update.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description SkillAdjusted SkillAdjusted The status of the update. Source code in src/routers/v1/skills_route.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @router . put ( \"/ {skill_id} \" , summary = \"Updates an skill\" , description = \"Updated the specified skills with the information provided\" , status_code = status . HTTP_200_OK , response_model = SkillAdjusted , ) async def update_skill ( skill : UpdateSkill , skill_id : int = Path ( description = \"The ID of the skill to update.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> SkillAdjusted : \"\"\"Endpoint to update an skill in the database. Args: skill (UpdateSkill): The information to update on the specified skill. skill_id (int): The id of the skill to update. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: SkillAdjusted: The status of the update. \"\"\" skill = await skills_service . update_skill ( skill_id , skill , db_session ) return skill","title":"skills_route"},{"location":"reference/routers/v1/skills_route/#src.routers.v1.skills_route.add_skill","text":"Endpoint to create a new skill in the database. Parameters: Name Type Description Default skill SkillSchema The skill to create. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description SkillDB SkillDB The information about the created skill. Source code in src/routers/v1/skills_route.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 @router . post ( \"/\" , summary = \"Create a new skill\" , description = \"Creates a new skill with the information provided\" , status_code = status . HTTP_201_CREATED , response_model = SkillDB , ) async def add_skill ( skill : SkillSchema , db_session : AsyncSession = Depends ( get_session )) -> SkillDB : \"\"\"Endpoint to create a new skill in the database. Args: skill (SkillSchema): The skill to create. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: SkillDB: The information about the created skill. \"\"\" skill = await skills_service . create_skill ( skill , db_session ) return skill","title":"add_skill()"},{"location":"reference/routers/v1/skills_route/#src.routers.v1.skills_route.delete_skill","text":"Endpoint for deleting an skill in the database. Parameters: Name Type Description Default skill_id int The skill to delete from the database. Path(description='The ID of the skill to delete.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description SkillDeleted SkillAdjusted The status indicating the result of the deletion. Source code in src/routers/v1/skills_route.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 @router . delete ( \"/ {skill_id} \" , summary = \"Delete the specified skill\" , description = \"Deletes the specified skill in the database\" , status_code = status . HTTP_200_OK , response_model = SkillAdjusted , ) async def delete_skill ( skill_id : int = Path ( description = \"The ID of the skill to delete.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> SkillAdjusted : \"\"\"Endpoint for deleting an skill in the database. Args: skill_id (int): The skill to delete from the database. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: SkillDeleted: The status indicating the result of the deletion. \"\"\" response = await skills_service . delete_skill ( skill_id , db_session ) return response","title":"delete_skill()"},{"location":"reference/routers/v1/skills_route/#src.routers.v1.skills_route.get_skill","text":"Endpoint for obtaining the specified skill from the database. Parameters: Name Type Description Default skill_id int The ID of the skill to obtain. Path(description='The ID of the skill to obtain.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description SkillDB SkillDB The obtained skill or nothing, in case nothing matches the ID. Source code in src/routers/v1/skills_route.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @router . get ( \"/ {skill_id} \" , summary = \"Get the specified skill\" , description = \"Get the specified skill from the database\" , status_code = status . HTTP_200_OK , response_model = SkillDB , ) async def get_skill ( skill_id : int = Path ( description = \"The ID of the skill to obtain.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> SkillDB : \"\"\"Endpoint for obtaining the specified skill from the database. Args: skill_id (int): The ID of the skill to obtain. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: SkillDB: The obtained skill or nothing, in case nothing matches the ID. \"\"\" skill = await skills_service . get_skill ( skill_id , db_session ) return skill","title":"get_skill()"},{"location":"reference/routers/v1/skills_route/#src.routers.v1.skills_route.get_skills","text":"Endpoint for obtaining all the skills in the database. Parameters: Name Type Description Default db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) skip int The number of items to skip. Defaults to 0. Query(default=0, description='The number of items to skip in the skill table') limit int The maximum number of items to return. Defaults to 100. Query(default=100, description='The maximum number to return from the skill table') Returns: Type Description Union [ List [ SkillDB ], None] List[SkillDB]: The list of skills obtained from the DB. Source code in src/routers/v1/skills_route.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @router . get ( \"/\" , summary = \"Get all skills\" , description = \"Get all skills stored in the database\" , status_code = status . HTTP_200_OK , response_model = List [ SkillDB ], ) async def get_skills ( db_session : AsyncSession = Depends ( get_session ), skip : int = Query ( default = 0 , description = \"The number of items to skip in the skill table\" ), limit : int = Query ( default = 100 , description = \"The maximum number to return from the skill table\" ), ) -> Union [ List [ SkillDB ], None ]: \"\"\"Endpoint for obtaining all the skills in the database. Args: db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. skip (int, optional): The number of items to skip. Defaults to 0. limit (int, optional): The maximum number of items to return. Defaults to 100. Returns: List[SkillDB]: The list of skills obtained from the DB. \"\"\" skills = await skills_service . get_skills ( skip , limit , db_session ) return skills # type: ignore[no-any-return]","title":"get_skills()"},{"location":"reference/routers/v1/skills_route/#src.routers.v1.skills_route.update_skill","text":"Endpoint to update an skill in the database. Parameters: Name Type Description Default skill UpdateSkill The information to update on the specified skill. required skill_id int The id of the skill to update. Path(description='The ID of the skill to update.') db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description SkillAdjusted SkillAdjusted The status of the update. Source code in src/routers/v1/skills_route.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @router . put ( \"/ {skill_id} \" , summary = \"Updates an skill\" , description = \"Updated the specified skills with the information provided\" , status_code = status . HTTP_200_OK , response_model = SkillAdjusted , ) async def update_skill ( skill : UpdateSkill , skill_id : int = Path ( description = \"The ID of the skill to update.\" ), db_session : AsyncSession = Depends ( get_session ), ) -> SkillAdjusted : \"\"\"Endpoint to update an skill in the database. Args: skill (UpdateSkill): The information to update on the specified skill. skill_id (int): The id of the skill to update. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: SkillAdjusted: The status of the update. \"\"\" skill = await skills_service . update_skill ( skill_id , skill , db_session ) return skill","title":"update_skill()"},{"location":"reference/routers/v1/user_route/","text":"All user related endpoints. create_user ( user_information , db_session = Depends ( get_session )) async Endpoint to create a new user in the database. Parameters: Name Type Description Default user_information CreateUser JSON containing the mail and password attributes. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description UserCreated UserCreated The status of the creation. Source code in src/routers/v1/user_route.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @router . post ( \"/\" , summary = \"Create a new user\" , description = \"Create a new user in the the database to grant access to the API\" , status_code = status . HTTP_201_CREATED , response_model = UserCreated , ) async def create_user ( user_information : CreateUser , db_session : AsyncSession = Depends ( get_session ), ) -> UserCreated : \"\"\"Endpoint to create a new user in the database. Args: user_information (CreateUser): JSON containing the ```mail``` and ```password``` attributes. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: UserCreated: The status of the creation. \"\"\" user = await user_service . create_new_user ( db_session , user_information . email , user_information . password ) return user delete_user ( user_information , db_session = Depends ( get_session )) async Endpoint to delete an existing user from the database. Parameters: Name Type Description Default user_information UserSchema JSON that contains the mail address of the user to delete. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description UserDeleted UserDeleted The status of deletion. Source code in src/routers/v1/user_route.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @router . delete ( \"/\" , summary = \"Deletes a user\" , description = \"Deletes the specified user from the database\" , status_code = status . HTTP_200_OK , response_model = UserDeleted , ) async def delete_user ( user_information : UserSchema , db_session : AsyncSession = Depends ( get_session ), ) -> UserDeleted : \"\"\"Endpoint to delete an existing user from the database. Args: user_information (UserSchema): JSON that contains the mail address of the user to delete. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: UserDeleted: The status of deletion. \"\"\" user = await user_service . delete_user ( db_session , user_information . email ) return user","title":"user_route"},{"location":"reference/routers/v1/user_route/#src.routers.v1.user_route.create_user","text":"Endpoint to create a new user in the database. Parameters: Name Type Description Default user_information CreateUser JSON containing the mail and password attributes. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description UserCreated UserCreated The status of the creation. Source code in src/routers/v1/user_route.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @router . post ( \"/\" , summary = \"Create a new user\" , description = \"Create a new user in the the database to grant access to the API\" , status_code = status . HTTP_201_CREATED , response_model = UserCreated , ) async def create_user ( user_information : CreateUser , db_session : AsyncSession = Depends ( get_session ), ) -> UserCreated : \"\"\"Endpoint to create a new user in the database. Args: user_information (CreateUser): JSON containing the ```mail``` and ```password``` attributes. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: UserCreated: The status of the creation. \"\"\" user = await user_service . create_new_user ( db_session , user_information . email , user_information . password ) return user","title":"create_user()"},{"location":"reference/routers/v1/user_route/#src.routers.v1.user_route.delete_user","text":"Endpoint to delete an existing user from the database. Parameters: Name Type Description Default user_information UserSchema JSON that contains the mail address of the user to delete. required db_session AsyncSession The session for the DB that will automatically injected using the Depends functionality of FastAPI. Depends(get_session) Returns: Name Type Description UserDeleted UserDeleted The status of deletion. Source code in src/routers/v1/user_route.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @router . delete ( \"/\" , summary = \"Deletes a user\" , description = \"Deletes the specified user from the database\" , status_code = status . HTTP_200_OK , response_model = UserDeleted , ) async def delete_user ( user_information : UserSchema , db_session : AsyncSession = Depends ( get_session ), ) -> UserDeleted : \"\"\"Endpoint to delete an existing user from the database. Args: user_information (UserSchema): JSON that contains the mail address of the user to delete. db_session (AsyncSession, optional): The session for the DB that will automatically injected using the ```Depends```functionality of FastAPI. Returns: UserDeleted: The status of deletion. \"\"\" user = await user_service . delete_user ( db_session , user_information . email ) return user","title":"delete_user()"},{"location":"reference/schemas/","text":"This folder contains all the schemas for the endpoints.","title":"schemas"},{"location":"reference/schemas/articles_schema/","text":"Article schemas. Article Bases: BaseModel Base model for an article. Source code in src/schemas/articles_schema.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Article ( BaseModel ): \"\"\"Base model for an article.\"\"\" author : str = Field ( example = \"Tobias Caliskan\" ) tags : List [ Tags ] = Field ( example = [ \"React\" , \"TailwindCSS\" , \"NextJS\" ]) image_url : str = Field ( example = \"www.asset-monitoring.de/nice_picture.svg\" ) title : str = Field ( example = \"This is my awesome title\" ) description : str = Field ( min_length = 40 , max_length = 140 , example = \"This is my awesome description\" , ) content : Optional [ str ] = Field ( example = \"The content preferable in markdown\" ) class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True Config Enable the ORM compatibility for SQLAlchemy. Source code in src/schemas/articles_schema.py 24 25 26 27 class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True ArticleCreated Bases: Article Schema for a created article. Source code in src/schemas/articles_schema.py 36 37 38 39 40 41 class ArticleCreated ( Article ): \"\"\"Schema for a created article.\"\"\" id : int content : str = Field ( example = \"My new content in markdown\" ) created_at : date ArticleDB Bases: Article Schema for an article obtained from the database. Source code in src/schemas/articles_schema.py 69 70 71 72 73 74 class ArticleDB ( Article ): \"\"\"Schema for an article obtained from the database.\"\"\" id : int created_at : date updated_at : Optional [ date ] ArticleDeleted Bases: BaseModel Schema for a deleted article. Source code in src/schemas/articles_schema.py 62 63 64 65 66 class ArticleDeleted ( BaseModel ): \"\"\"Schema for a deleted article.\"\"\" article_id : int = Field ( example = 43 ) status : str = Field ( example = \"Article deleted\" ) ArticleUpdated Bases: BaseModel Schema for a updated article. Source code in src/schemas/articles_schema.py 55 56 57 58 59 class ArticleUpdated ( BaseModel ): \"\"\"Schema for a updated article.\"\"\" article_id : int = Field ( example = 32 ) status : str = Field ( example = \"Article updated\" ) CreateArticle Bases: Article Schema for creating a new article. Source code in src/schemas/articles_schema.py 30 31 32 33 class CreateArticle ( Article ): \"\"\"Schema for creating a new article.\"\"\" content : str = Field ( example = \"My awesome title\" ) UpdateArticle Bases: Article Schema for updating an article. Inherits from the Article model and make all fields optional, since there is no partial option available in Pydantic :( Source code in src/schemas/articles_schema.py 44 45 46 47 48 49 50 51 52 class UpdateArticle ( Article ): \"\"\"Schema for updating an article. Inherits from the Article model and make all fields optional, since there is no partial option available in Pydantic :( \"\"\" __annotations__ = { k : Optional [ v ] for k , v in Article . __annotations__ . items ()}","title":"articles_schema"},{"location":"reference/schemas/articles_schema/#src.schemas.articles_schema.Article","text":"Bases: BaseModel Base model for an article. Source code in src/schemas/articles_schema.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Article ( BaseModel ): \"\"\"Base model for an article.\"\"\" author : str = Field ( example = \"Tobias Caliskan\" ) tags : List [ Tags ] = Field ( example = [ \"React\" , \"TailwindCSS\" , \"NextJS\" ]) image_url : str = Field ( example = \"www.asset-monitoring.de/nice_picture.svg\" ) title : str = Field ( example = \"This is my awesome title\" ) description : str = Field ( min_length = 40 , max_length = 140 , example = \"This is my awesome description\" , ) content : Optional [ str ] = Field ( example = \"The content preferable in markdown\" ) class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True","title":"Article"},{"location":"reference/schemas/articles_schema/#src.schemas.articles_schema.Article.Config","text":"Enable the ORM compatibility for SQLAlchemy. Source code in src/schemas/articles_schema.py 24 25 26 27 class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True","title":"Config"},{"location":"reference/schemas/articles_schema/#src.schemas.articles_schema.ArticleCreated","text":"Bases: Article Schema for a created article. Source code in src/schemas/articles_schema.py 36 37 38 39 40 41 class ArticleCreated ( Article ): \"\"\"Schema for a created article.\"\"\" id : int content : str = Field ( example = \"My new content in markdown\" ) created_at : date","title":"ArticleCreated"},{"location":"reference/schemas/articles_schema/#src.schemas.articles_schema.ArticleDB","text":"Bases: Article Schema for an article obtained from the database. Source code in src/schemas/articles_schema.py 69 70 71 72 73 74 class ArticleDB ( Article ): \"\"\"Schema for an article obtained from the database.\"\"\" id : int created_at : date updated_at : Optional [ date ]","title":"ArticleDB"},{"location":"reference/schemas/articles_schema/#src.schemas.articles_schema.ArticleDeleted","text":"Bases: BaseModel Schema for a deleted article. Source code in src/schemas/articles_schema.py 62 63 64 65 66 class ArticleDeleted ( BaseModel ): \"\"\"Schema for a deleted article.\"\"\" article_id : int = Field ( example = 43 ) status : str = Field ( example = \"Article deleted\" )","title":"ArticleDeleted"},{"location":"reference/schemas/articles_schema/#src.schemas.articles_schema.ArticleUpdated","text":"Bases: BaseModel Schema for a updated article. Source code in src/schemas/articles_schema.py 55 56 57 58 59 class ArticleUpdated ( BaseModel ): \"\"\"Schema for a updated article.\"\"\" article_id : int = Field ( example = 32 ) status : str = Field ( example = \"Article updated\" )","title":"ArticleUpdated"},{"location":"reference/schemas/articles_schema/#src.schemas.articles_schema.CreateArticle","text":"Bases: Article Schema for creating a new article. Source code in src/schemas/articles_schema.py 30 31 32 33 class CreateArticle ( Article ): \"\"\"Schema for creating a new article.\"\"\" content : str = Field ( example = \"My awesome title\" )","title":"CreateArticle"},{"location":"reference/schemas/articles_schema/#src.schemas.articles_schema.UpdateArticle","text":"Bases: Article Schema for updating an article. Inherits from the Article model and make all fields optional, since there is no partial option available in Pydantic :( Source code in src/schemas/articles_schema.py 44 45 46 47 48 49 50 51 52 class UpdateArticle ( Article ): \"\"\"Schema for updating an article. Inherits from the Article model and make all fields optional, since there is no partial option available in Pydantic :( \"\"\" __annotations__ = { k : Optional [ v ] for k , v in Article . __annotations__ . items ()}","title":"UpdateArticle"},{"location":"reference/schemas/auth_schema/","text":"Auth schemas. AuthSchema Bases: BaseModel Base model for the Authentication. Source code in src/schemas/auth_schema.py 7 8 9 10 11 class AuthSchema ( BaseModel ): \"\"\"Base model for the Authentication.\"\"\" email : EmailStr password : str AuthTokenSchema Bases: BaseModel Model representing the access tokens. Source code in src/schemas/auth_schema.py 20 21 22 23 24 class AuthTokenSchema ( BaseModel ): \"\"\"Model representing the access tokens.\"\"\" access_token : Token refresh_token : Token RefreshSchema Bases: BaseModel Model for refreshing an outdated access token. Source code in src/schemas/auth_schema.py 14 15 16 17 class RefreshSchema ( BaseModel ): \"\"\"Model for refreshing an outdated access token.\"\"\" refresh_token : str","title":"auth_schema"},{"location":"reference/schemas/auth_schema/#src.schemas.auth_schema.AuthSchema","text":"Bases: BaseModel Base model for the Authentication. Source code in src/schemas/auth_schema.py 7 8 9 10 11 class AuthSchema ( BaseModel ): \"\"\"Base model for the Authentication.\"\"\" email : EmailStr password : str","title":"AuthSchema"},{"location":"reference/schemas/auth_schema/#src.schemas.auth_schema.AuthTokenSchema","text":"Bases: BaseModel Model representing the access tokens. Source code in src/schemas/auth_schema.py 20 21 22 23 24 class AuthTokenSchema ( BaseModel ): \"\"\"Model representing the access tokens.\"\"\" access_token : Token refresh_token : Token","title":"AuthTokenSchema"},{"location":"reference/schemas/auth_schema/#src.schemas.auth_schema.RefreshSchema","text":"Bases: BaseModel Model for refreshing an outdated access token. Source code in src/schemas/auth_schema.py 14 15 16 17 class RefreshSchema ( BaseModel ): \"\"\"Model for refreshing an outdated access token.\"\"\" refresh_token : str","title":"RefreshSchema"},{"location":"reference/schemas/projects_schema/","text":"Projects schemas. Project Bases: BaseModel Base model for a project. Source code in src/schemas/projects_schema.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Project ( BaseModel ): \"\"\"Base model for a project.\"\"\" title : str = Field ( example = \"This is my awesome title\" ) image_url : str = Field ( example = \"www.asset-monitoring.de/nice_picture.svg\" ) description : str = Field ( min_length = 40 , max_length = 140 , example = \"This is my awesome description\" , ) project_url : str = Field ( example = \"www.asset-monitoring.de\" ) tags : List [ Tags ] = Field ( example = [ \"React\" , \"TailwindCSS\" , \"NextJS\" ]) class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True Config Enable the ORM compatibility for SQLAlchemy. Source code in src/schemas/projects_schema.py 22 23 24 25 class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True ProjectCreated Bases: Project Schema for a created project. Source code in src/schemas/projects_schema.py 28 29 30 31 class ProjectCreated ( Project ): \"\"\"Schema for a created project.\"\"\" id : int ProjectDB Bases: Project Schema representing the project obtained from the database. Source code in src/schemas/projects_schema.py 58 59 60 61 class ProjectDB ( Project ): \"\"\"Schema representing the project obtained from the database.\"\"\" id : int ProjectDeleted Bases: BaseModel Schema for a deleted project. Source code in src/schemas/projects_schema.py 51 52 53 54 55 class ProjectDeleted ( BaseModel ): \"\"\"Schema for a deleted project.\"\"\" project_id : int = Field ( example = 43 ) status : str = Field ( example = \"Project deleted\" ) ProjectUpdated Bases: BaseModel Schema for a updated project. Source code in src/schemas/projects_schema.py 44 45 46 47 48 class ProjectUpdated ( BaseModel ): \"\"\"Schema for a updated project.\"\"\" project_id : int = Field ( example = 32 ) status : str = Field ( example = \"Project updated\" ) UpdateProject Bases: Project Schema for updating an project. Inherits from the Project model and make all fields optional, since there is no partial option available in Pydantic :(. Source code in src/schemas/projects_schema.py 34 35 36 37 38 39 40 41 class UpdateProject ( Project ): \"\"\"Schema for updating an project. Inherits from the Project model and make all fields optional, since there is no partial option available in Pydantic :(. \"\"\" __annotations__ = { k : Optional [ v ] for k , v in Project . __annotations__ . items ()}","title":"projects_schema"},{"location":"reference/schemas/projects_schema/#src.schemas.projects_schema.Project","text":"Bases: BaseModel Base model for a project. Source code in src/schemas/projects_schema.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Project ( BaseModel ): \"\"\"Base model for a project.\"\"\" title : str = Field ( example = \"This is my awesome title\" ) image_url : str = Field ( example = \"www.asset-monitoring.de/nice_picture.svg\" ) description : str = Field ( min_length = 40 , max_length = 140 , example = \"This is my awesome description\" , ) project_url : str = Field ( example = \"www.asset-monitoring.de\" ) tags : List [ Tags ] = Field ( example = [ \"React\" , \"TailwindCSS\" , \"NextJS\" ]) class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True","title":"Project"},{"location":"reference/schemas/projects_schema/#src.schemas.projects_schema.Project.Config","text":"Enable the ORM compatibility for SQLAlchemy. Source code in src/schemas/projects_schema.py 22 23 24 25 class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True","title":"Config"},{"location":"reference/schemas/projects_schema/#src.schemas.projects_schema.ProjectCreated","text":"Bases: Project Schema for a created project. Source code in src/schemas/projects_schema.py 28 29 30 31 class ProjectCreated ( Project ): \"\"\"Schema for a created project.\"\"\" id : int","title":"ProjectCreated"},{"location":"reference/schemas/projects_schema/#src.schemas.projects_schema.ProjectDB","text":"Bases: Project Schema representing the project obtained from the database. Source code in src/schemas/projects_schema.py 58 59 60 61 class ProjectDB ( Project ): \"\"\"Schema representing the project obtained from the database.\"\"\" id : int","title":"ProjectDB"},{"location":"reference/schemas/projects_schema/#src.schemas.projects_schema.ProjectDeleted","text":"Bases: BaseModel Schema for a deleted project. Source code in src/schemas/projects_schema.py 51 52 53 54 55 class ProjectDeleted ( BaseModel ): \"\"\"Schema for a deleted project.\"\"\" project_id : int = Field ( example = 43 ) status : str = Field ( example = \"Project deleted\" )","title":"ProjectDeleted"},{"location":"reference/schemas/projects_schema/#src.schemas.projects_schema.ProjectUpdated","text":"Bases: BaseModel Schema for a updated project. Source code in src/schemas/projects_schema.py 44 45 46 47 48 class ProjectUpdated ( BaseModel ): \"\"\"Schema for a updated project.\"\"\" project_id : int = Field ( example = 32 ) status : str = Field ( example = \"Project updated\" )","title":"ProjectUpdated"},{"location":"reference/schemas/projects_schema/#src.schemas.projects_schema.UpdateProject","text":"Bases: Project Schema for updating an project. Inherits from the Project model and make all fields optional, since there is no partial option available in Pydantic :(. Source code in src/schemas/projects_schema.py 34 35 36 37 38 39 40 41 class UpdateProject ( Project ): \"\"\"Schema for updating an project. Inherits from the Project model and make all fields optional, since there is no partial option available in Pydantic :(. \"\"\" __annotations__ = { k : Optional [ v ] for k , v in Project . __annotations__ . items ()}","title":"UpdateProject"},{"location":"reference/schemas/skills_schema/","text":"Skills schemas. SkillAdjusted Bases: BaseModel The model for deleting a user. Source code in src/schemas/skills_schema.py 36 37 38 39 40 class SkillAdjusted ( BaseModel ): \"\"\"The model for deleting a user.\"\"\" skill_id : int status : str = Field ( example = \"User successfully deleted\" ) SkillDB Bases: SkillSchema The model representing the result from the DB. Source code in src/schemas/skills_schema.py 15 16 17 18 19 20 21 22 23 class SkillDB ( SkillSchema ): \"\"\"The model representing the result from the DB.\"\"\" id : int class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True Config Enable the ORM compatibility for SQLAlchemy. Source code in src/schemas/skills_schema.py 20 21 22 23 class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True SkillSchema Bases: BaseModel The base model for managing skills. Source code in src/schemas/skills_schema.py 7 8 9 10 11 12 class SkillSchema ( BaseModel ): \"\"\"The base model for managing skills.\"\"\" name : str = Field ( example = \"TailwindCSS\" , description = \"The name of the skill.\" ) category : str = Field ( example = \"Languages\" , description = \"The category of the skill.\" ) experience : int = Field ( example = 2 , ge = 1 , le = 3 , description = \"The level of experience for the skill.\" ) UpdateSkill Bases: SkillSchema Schema for updating an skill. Inherits from the Skill model and make all fields optional, since there is no partial option available in Pydantic :(. Source code in src/schemas/skills_schema.py 26 27 28 29 30 31 32 33 class UpdateSkill ( SkillSchema ): \"\"\"Schema for updating an skill. Inherits from the Skill model and make all fields optional, since there is no partial option available in Pydantic :(. \"\"\" __annotations__ = { k : Optional [ v ] for k , v in SkillSchema . __annotations__ . items ()}","title":"skills_schema"},{"location":"reference/schemas/skills_schema/#src.schemas.skills_schema.SkillAdjusted","text":"Bases: BaseModel The model for deleting a user. Source code in src/schemas/skills_schema.py 36 37 38 39 40 class SkillAdjusted ( BaseModel ): \"\"\"The model for deleting a user.\"\"\" skill_id : int status : str = Field ( example = \"User successfully deleted\" )","title":"SkillAdjusted"},{"location":"reference/schemas/skills_schema/#src.schemas.skills_schema.SkillDB","text":"Bases: SkillSchema The model representing the result from the DB. Source code in src/schemas/skills_schema.py 15 16 17 18 19 20 21 22 23 class SkillDB ( SkillSchema ): \"\"\"The model representing the result from the DB.\"\"\" id : int class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True","title":"SkillDB"},{"location":"reference/schemas/skills_schema/#src.schemas.skills_schema.SkillDB.Config","text":"Enable the ORM compatibility for SQLAlchemy. Source code in src/schemas/skills_schema.py 20 21 22 23 class Config : \"\"\"Enable the ORM compatibility for SQLAlchemy.\"\"\" orm_mode = True","title":"Config"},{"location":"reference/schemas/skills_schema/#src.schemas.skills_schema.SkillSchema","text":"Bases: BaseModel The base model for managing skills. Source code in src/schemas/skills_schema.py 7 8 9 10 11 12 class SkillSchema ( BaseModel ): \"\"\"The base model for managing skills.\"\"\" name : str = Field ( example = \"TailwindCSS\" , description = \"The name of the skill.\" ) category : str = Field ( example = \"Languages\" , description = \"The category of the skill.\" ) experience : int = Field ( example = 2 , ge = 1 , le = 3 , description = \"The level of experience for the skill.\" )","title":"SkillSchema"},{"location":"reference/schemas/skills_schema/#src.schemas.skills_schema.UpdateSkill","text":"Bases: SkillSchema Schema for updating an skill. Inherits from the Skill model and make all fields optional, since there is no partial option available in Pydantic :(. Source code in src/schemas/skills_schema.py 26 27 28 29 30 31 32 33 class UpdateSkill ( SkillSchema ): \"\"\"Schema for updating an skill. Inherits from the Skill model and make all fields optional, since there is no partial option available in Pydantic :(. \"\"\" __annotations__ = { k : Optional [ v ] for k , v in SkillSchema . __annotations__ . items ()}","title":"UpdateSkill"},{"location":"reference/schemas/tags_schema/","text":"Tags schemas. Tags Bases: BaseModel Base schema for the Tags model. Source code in src/schemas/tags_schema.py 5 6 7 8 9 class Tags ( BaseModel ): \"\"\"Base schema for the Tags model.\"\"\" icon_name : str name : str","title":"tags_schema"},{"location":"reference/schemas/tags_schema/#src.schemas.tags_schema.Tags","text":"Bases: BaseModel Base schema for the Tags model. Source code in src/schemas/tags_schema.py 5 6 7 8 9 class Tags ( BaseModel ): \"\"\"Base schema for the Tags model.\"\"\" icon_name : str name : str","title":"Tags"},{"location":"reference/schemas/token_schema/","text":"Token schemas. AuthToken Bases: BaseModel The auth token object that consist of a TokenTypes and the Token itself. Source code in src/schemas/token_schema.py 23 24 25 26 27 28 29 30 31 class AuthToken ( BaseModel ): \"\"\"The auth token object that consist of a ```TokenTypes```and the ```Token``` itself.\"\"\" __root__ : Dict [ TokenTypes , Token ] class Config : \"\"\"Configure the model to use enum values.\"\"\" use_enum_values = True Config Configure the model to use enum values. Source code in src/schemas/token_schema.py 28 29 30 31 class Config : \"\"\"Configure the model to use enum values.\"\"\" use_enum_values = True Token Bases: BaseModel The general Token object. Source code in src/schemas/token_schema.py 16 17 18 19 20 class Token ( BaseModel ): \"\"\"The general ```Token``` object.\"\"\" token : str expires : datetime TokenPayload Bases: BaseModel The decoded token payload. Source code in src/schemas/token_schema.py 34 35 36 37 38 39 40 class TokenPayload ( BaseModel ): \"\"\"The decoded token payload.\"\"\" sub : str iat : int exp : int type : TokenTypes TokenTypes Bases: str , Enum The types of tokens that can be issued. Source code in src/schemas/token_schema.py 9 10 11 12 13 class TokenTypes ( str , Enum ): \"\"\"The types of tokens that can be issued.\"\"\" ACCESS_TOKEN = \"access_token\" REFRESH_TOKEN = \"refresh_token\"","title":"token_schema"},{"location":"reference/schemas/token_schema/#src.schemas.token_schema.AuthToken","text":"Bases: BaseModel The auth token object that consist of a TokenTypes and the Token itself. Source code in src/schemas/token_schema.py 23 24 25 26 27 28 29 30 31 class AuthToken ( BaseModel ): \"\"\"The auth token object that consist of a ```TokenTypes```and the ```Token``` itself.\"\"\" __root__ : Dict [ TokenTypes , Token ] class Config : \"\"\"Configure the model to use enum values.\"\"\" use_enum_values = True","title":"AuthToken"},{"location":"reference/schemas/token_schema/#src.schemas.token_schema.AuthToken.Config","text":"Configure the model to use enum values. Source code in src/schemas/token_schema.py 28 29 30 31 class Config : \"\"\"Configure the model to use enum values.\"\"\" use_enum_values = True","title":"Config"},{"location":"reference/schemas/token_schema/#src.schemas.token_schema.Token","text":"Bases: BaseModel The general Token object. Source code in src/schemas/token_schema.py 16 17 18 19 20 class Token ( BaseModel ): \"\"\"The general ```Token``` object.\"\"\" token : str expires : datetime","title":"Token"},{"location":"reference/schemas/token_schema/#src.schemas.token_schema.TokenPayload","text":"Bases: BaseModel The decoded token payload. Source code in src/schemas/token_schema.py 34 35 36 37 38 39 40 class TokenPayload ( BaseModel ): \"\"\"The decoded token payload.\"\"\" sub : str iat : int exp : int type : TokenTypes","title":"TokenPayload"},{"location":"reference/schemas/token_schema/#src.schemas.token_schema.TokenTypes","text":"Bases: str , Enum The types of tokens that can be issued. Source code in src/schemas/token_schema.py 9 10 11 12 13 class TokenTypes ( str , Enum ): \"\"\"The types of tokens that can be issued.\"\"\" ACCESS_TOKEN = \"access_token\" REFRESH_TOKEN = \"refresh_token\"","title":"TokenTypes"},{"location":"reference/schemas/user_schema/","text":"User schemas. CreateUser Bases: UserSchema The model for creating a new user. Source code in src/schemas/user_schema.py 11 12 13 14 class CreateUser ( UserSchema ): \"\"\"The model for creating a new user.\"\"\" password : str = Field ( example = \"mysupersecretpassword\" ) UserCreated Bases: UserSchema The model for created users. Source code in src/schemas/user_schema.py 17 18 19 20 class UserCreated ( UserSchema ): \"\"\"The model for created users.\"\"\" status : str = Field ( example = \"User successfully created\" ) UserDB Bases: UserSchema The model representing the result from the DB. Source code in src/schemas/user_schema.py 29 30 31 32 33 class UserDB ( UserSchema ): \"\"\"The model representing the result from the DB.\"\"\" id : int password : str = Field ( example = \"mysupersecretpassword\" ) UserDeleted Bases: UserSchema The model for deleting a user. Source code in src/schemas/user_schema.py 23 24 25 26 class UserDeleted ( UserSchema ): \"\"\"The model for deleting a user.\"\"\" status : str = Field ( example = \"User successfully deleted\" ) UserSchema Bases: BaseModel The base model for managing users. Source code in src/schemas/user_schema.py 5 6 7 8 class UserSchema ( BaseModel ): \"\"\"The base model for managing users.\"\"\" email : str = Field ( example = \"tobiascaliskan@gmx.de\" )","title":"user_schema"},{"location":"reference/schemas/user_schema/#src.schemas.user_schema.CreateUser","text":"Bases: UserSchema The model for creating a new user. Source code in src/schemas/user_schema.py 11 12 13 14 class CreateUser ( UserSchema ): \"\"\"The model for creating a new user.\"\"\" password : str = Field ( example = \"mysupersecretpassword\" )","title":"CreateUser"},{"location":"reference/schemas/user_schema/#src.schemas.user_schema.UserCreated","text":"Bases: UserSchema The model for created users. Source code in src/schemas/user_schema.py 17 18 19 20 class UserCreated ( UserSchema ): \"\"\"The model for created users.\"\"\" status : str = Field ( example = \"User successfully created\" )","title":"UserCreated"},{"location":"reference/schemas/user_schema/#src.schemas.user_schema.UserDB","text":"Bases: UserSchema The model representing the result from the DB. Source code in src/schemas/user_schema.py 29 30 31 32 33 class UserDB ( UserSchema ): \"\"\"The model representing the result from the DB.\"\"\" id : int password : str = Field ( example = \"mysupersecretpassword\" )","title":"UserDB"},{"location":"reference/schemas/user_schema/#src.schemas.user_schema.UserDeleted","text":"Bases: UserSchema The model for deleting a user. Source code in src/schemas/user_schema.py 23 24 25 26 class UserDeleted ( UserSchema ): \"\"\"The model for deleting a user.\"\"\" status : str = Field ( example = \"User successfully deleted\" )","title":"UserDeleted"},{"location":"reference/schemas/user_schema/#src.schemas.user_schema.UserSchema","text":"Bases: BaseModel The base model for managing users. Source code in src/schemas/user_schema.py 5 6 7 8 class UserSchema ( BaseModel ): \"\"\"The base model for managing users.\"\"\" email : str = Field ( example = \"tobiascaliskan@gmx.de\" )","title":"UserSchema"},{"location":"reference/services/","text":"This folder contains all scripts that are representing the business logic for the respective endpoints.","title":"services"},{"location":"reference/services/articles_service/","text":"Articles service. ArticlesService Provides all services to manage articles in the database. Source code in src/services/articles_service.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 class ArticlesService : \"\"\"Provides all services to manage articles in the database.\"\"\" async def get_article ( self , article_id : int , db_session : AsyncSession ) -> Union [ ArticleDB , None ]: \"\"\"Get the specified article from the database. Args: article_id: The ID of the article to obtain from the database. db_session: The session for the database. Returns: The result of the database. Can be either of type ``ArticleDB`` or ``None``, in case no row matches the provided ID. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the article. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Article ) . filter ( Article . id == article_id )) article : ArticleDB = res . scalars () . first () if article is not None : return article else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the article\" , ) from BaseException async def get_articles ( self , skip : int , limit : int , db_session : AsyncSession ) -> Union [ List [ Article ], None ]: \"\"\"Get all articles from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: The result of the database. Can be either of type ``List[Article]`` or ``None``, in case no articles are stored in the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the articles. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Article )) articles_list : List [ Article ] = res . all () if articles_list is not None : return articles_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all articles\" , ) from BaseException async def delete_article ( self , article_id : int , db_session : AsyncSession ) -> ArticleDeleted : \"\"\"Delete the specified article from the database. Args: article_id (int): The ID of the article to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the article. Returns: ArticleDeleted: The information, whether the specified article was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Article ) . where ( Article . id == article_id )) if res . rowcount != 0 : await db_session . commit () return { \"article_id\" : article_id , \"status\" : \"Article deleted\" } else : return { \"article_id\" : article_id , \"status\" : \"Article not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the article\" , ) from BaseException async def create_article ( self , article : Article , db_session : AsyncSession ) -> ArticleCreated : \"\"\"Insert the provided article in the database. Args: article (CreateArticle): The article object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the article. Returns: ArticleCreated: The created article including the ID. \"\"\" create_article = article . dict () try : new_article = Article ( ** create_article , created_at = datetime . now (), ) db_session . add ( new_article ) await db_session . commit () return new_article # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the article\" , ) from BaseException async def update_article ( self , article_id : int , article : UpdateArticle , db_session : AsyncSession ) -> ArticleUpdated : \"\"\"Update the specified article in the database. Args: article_id (int): The ID of the article to update. article (UpdateArticle): The information that shall be updated in the article. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the article. Returns: ArticleUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_article = article . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Article ) . where ( Article . id == article_id ) . values ( ** update_article , updated_at = datetime . now (), ) ) if res . rowcount != 0 : await db_session . commit () return ArticleUpdated ( article_id = article_id , status = \"Article updated\" ) else : return ArticleUpdated ( article_id = article_id , status = \"Article not found\" ) except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the article\" , ) from BaseException create_article ( article , db_session ) async Insert the provided article in the database. Parameters: Name Type Description Default article CreateArticle The article object that should be created in the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when creating the article. Returns: Name Type Description ArticleCreated ArticleCreated The created article including the ID. Source code in src/services/articles_service.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 async def create_article ( self , article : Article , db_session : AsyncSession ) -> ArticleCreated : \"\"\"Insert the provided article in the database. Args: article (CreateArticle): The article object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the article. Returns: ArticleCreated: The created article including the ID. \"\"\" create_article = article . dict () try : new_article = Article ( ** create_article , created_at = datetime . now (), ) db_session . add ( new_article ) await db_session . commit () return new_article # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the article\" , ) from BaseException delete_article ( article_id , db_session ) async Delete the specified article from the database. Parameters: Name Type Description Default article_id int The ID of the article to delete from the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when deleting the article. Returns: Name Type Description ArticleDeleted ArticleDeleted The information, whether the specified article was successfully deleted. Source code in src/services/articles_service.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 async def delete_article ( self , article_id : int , db_session : AsyncSession ) -> ArticleDeleted : \"\"\"Delete the specified article from the database. Args: article_id (int): The ID of the article to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the article. Returns: ArticleDeleted: The information, whether the specified article was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Article ) . where ( Article . id == article_id )) if res . rowcount != 0 : await db_session . commit () return { \"article_id\" : article_id , \"status\" : \"Article deleted\" } else : return { \"article_id\" : article_id , \"status\" : \"Article not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the article\" , ) from BaseException get_article ( article_id , db_session ) async Get the specified article from the database. Parameters: Name Type Description Default article_id int The ID of the article to obtain from the database. required db_session AsyncSession The session for the database. required Returns: Type Description Union [ ArticleDB , None] The result of the database. Can be either of type ArticleDB or None , in case no row matches the provided ID. Raises: Type Description HTTPException Is being thrown as soon as an error occurs when obtaining the article. Source code in src/services/articles_service.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 async def get_article ( self , article_id : int , db_session : AsyncSession ) -> Union [ ArticleDB , None ]: \"\"\"Get the specified article from the database. Args: article_id: The ID of the article to obtain from the database. db_session: The session for the database. Returns: The result of the database. Can be either of type ``ArticleDB`` or ``None``, in case no row matches the provided ID. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the article. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Article ) . filter ( Article . id == article_id )) article : ArticleDB = res . scalars () . first () if article is not None : return article else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the article\" , ) from BaseException get_articles ( skip , limit , db_session ) async Get all articles from the database. Parameters: Name Type Description Default skip int Number of elements to skip from the result set. required limit int Maximum number of elements to return. required db_session AsyncSession The session for the database. required Returns: Type Description Union [ List [ Article ], None] The result of the database. Can be either of type List[Article] or None , in case no articles are stored in the DB. Raises: Type Description HTTPException Is being thrown as soon as an error occurs when obtaining the articles. Source code in src/services/articles_service.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 async def get_articles ( self , skip : int , limit : int , db_session : AsyncSession ) -> Union [ List [ Article ], None ]: \"\"\"Get all articles from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: The result of the database. Can be either of type ``List[Article]`` or ``None``, in case no articles are stored in the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the articles. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Article )) articles_list : List [ Article ] = res . all () if articles_list is not None : return articles_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all articles\" , ) from BaseException update_article ( article_id , article , db_session ) async Update the specified article in the database. Parameters: Name Type Description Default article_id int The ID of the article to update. required article UpdateArticle The information that shall be updated in the article. required db_session AsyncSession The session for the DB. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when updating the article. Returns: Name Type Description ArticleUpdated ArticleUpdated The status that indicates, whether the update was successful. Source code in src/services/articles_service.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 async def update_article ( self , article_id : int , article : UpdateArticle , db_session : AsyncSession ) -> ArticleUpdated : \"\"\"Update the specified article in the database. Args: article_id (int): The ID of the article to update. article (UpdateArticle): The information that shall be updated in the article. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the article. Returns: ArticleUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_article = article . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Article ) . where ( Article . id == article_id ) . values ( ** update_article , updated_at = datetime . now (), ) ) if res . rowcount != 0 : await db_session . commit () return ArticleUpdated ( article_id = article_id , status = \"Article updated\" ) else : return ArticleUpdated ( article_id = article_id , status = \"Article not found\" ) except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the article\" , ) from BaseException","title":"articles_service"},{"location":"reference/services/articles_service/#src.services.articles_service.ArticlesService","text":"Provides all services to manage articles in the database. Source code in src/services/articles_service.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 class ArticlesService : \"\"\"Provides all services to manage articles in the database.\"\"\" async def get_article ( self , article_id : int , db_session : AsyncSession ) -> Union [ ArticleDB , None ]: \"\"\"Get the specified article from the database. Args: article_id: The ID of the article to obtain from the database. db_session: The session for the database. Returns: The result of the database. Can be either of type ``ArticleDB`` or ``None``, in case no row matches the provided ID. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the article. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Article ) . filter ( Article . id == article_id )) article : ArticleDB = res . scalars () . first () if article is not None : return article else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the article\" , ) from BaseException async def get_articles ( self , skip : int , limit : int , db_session : AsyncSession ) -> Union [ List [ Article ], None ]: \"\"\"Get all articles from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: The result of the database. Can be either of type ``List[Article]`` or ``None``, in case no articles are stored in the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the articles. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Article )) articles_list : List [ Article ] = res . all () if articles_list is not None : return articles_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all articles\" , ) from BaseException async def delete_article ( self , article_id : int , db_session : AsyncSession ) -> ArticleDeleted : \"\"\"Delete the specified article from the database. Args: article_id (int): The ID of the article to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the article. Returns: ArticleDeleted: The information, whether the specified article was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Article ) . where ( Article . id == article_id )) if res . rowcount != 0 : await db_session . commit () return { \"article_id\" : article_id , \"status\" : \"Article deleted\" } else : return { \"article_id\" : article_id , \"status\" : \"Article not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the article\" , ) from BaseException async def create_article ( self , article : Article , db_session : AsyncSession ) -> ArticleCreated : \"\"\"Insert the provided article in the database. Args: article (CreateArticle): The article object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the article. Returns: ArticleCreated: The created article including the ID. \"\"\" create_article = article . dict () try : new_article = Article ( ** create_article , created_at = datetime . now (), ) db_session . add ( new_article ) await db_session . commit () return new_article # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the article\" , ) from BaseException async def update_article ( self , article_id : int , article : UpdateArticle , db_session : AsyncSession ) -> ArticleUpdated : \"\"\"Update the specified article in the database. Args: article_id (int): The ID of the article to update. article (UpdateArticle): The information that shall be updated in the article. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the article. Returns: ArticleUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_article = article . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Article ) . where ( Article . id == article_id ) . values ( ** update_article , updated_at = datetime . now (), ) ) if res . rowcount != 0 : await db_session . commit () return ArticleUpdated ( article_id = article_id , status = \"Article updated\" ) else : return ArticleUpdated ( article_id = article_id , status = \"Article not found\" ) except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the article\" , ) from BaseException","title":"ArticlesService"},{"location":"reference/services/articles_service/#src.services.articles_service.ArticlesService.create_article","text":"Insert the provided article in the database. Parameters: Name Type Description Default article CreateArticle The article object that should be created in the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when creating the article. Returns: Name Type Description ArticleCreated ArticleCreated The created article including the ID. Source code in src/services/articles_service.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 async def create_article ( self , article : Article , db_session : AsyncSession ) -> ArticleCreated : \"\"\"Insert the provided article in the database. Args: article (CreateArticle): The article object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the article. Returns: ArticleCreated: The created article including the ID. \"\"\" create_article = article . dict () try : new_article = Article ( ** create_article , created_at = datetime . now (), ) db_session . add ( new_article ) await db_session . commit () return new_article # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the article\" , ) from BaseException","title":"create_article()"},{"location":"reference/services/articles_service/#src.services.articles_service.ArticlesService.delete_article","text":"Delete the specified article from the database. Parameters: Name Type Description Default article_id int The ID of the article to delete from the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when deleting the article. Returns: Name Type Description ArticleDeleted ArticleDeleted The information, whether the specified article was successfully deleted. Source code in src/services/articles_service.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 async def delete_article ( self , article_id : int , db_session : AsyncSession ) -> ArticleDeleted : \"\"\"Delete the specified article from the database. Args: article_id (int): The ID of the article to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the article. Returns: ArticleDeleted: The information, whether the specified article was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Article ) . where ( Article . id == article_id )) if res . rowcount != 0 : await db_session . commit () return { \"article_id\" : article_id , \"status\" : \"Article deleted\" } else : return { \"article_id\" : article_id , \"status\" : \"Article not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the article\" , ) from BaseException","title":"delete_article()"},{"location":"reference/services/articles_service/#src.services.articles_service.ArticlesService.get_article","text":"Get the specified article from the database. Parameters: Name Type Description Default article_id int The ID of the article to obtain from the database. required db_session AsyncSession The session for the database. required Returns: Type Description Union [ ArticleDB , None] The result of the database. Can be either of type ArticleDB or None , in case no row matches the provided ID. Raises: Type Description HTTPException Is being thrown as soon as an error occurs when obtaining the article. Source code in src/services/articles_service.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 async def get_article ( self , article_id : int , db_session : AsyncSession ) -> Union [ ArticleDB , None ]: \"\"\"Get the specified article from the database. Args: article_id: The ID of the article to obtain from the database. db_session: The session for the database. Returns: The result of the database. Can be either of type ``ArticleDB`` or ``None``, in case no row matches the provided ID. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the article. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Article ) . filter ( Article . id == article_id )) article : ArticleDB = res . scalars () . first () if article is not None : return article else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the article\" , ) from BaseException","title":"get_article()"},{"location":"reference/services/articles_service/#src.services.articles_service.ArticlesService.get_articles","text":"Get all articles from the database. Parameters: Name Type Description Default skip int Number of elements to skip from the result set. required limit int Maximum number of elements to return. required db_session AsyncSession The session for the database. required Returns: Type Description Union [ List [ Article ], None] The result of the database. Can be either of type List[Article] or None , in case no articles are stored in the DB. Raises: Type Description HTTPException Is being thrown as soon as an error occurs when obtaining the articles. Source code in src/services/articles_service.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 async def get_articles ( self , skip : int , limit : int , db_session : AsyncSession ) -> Union [ List [ Article ], None ]: \"\"\"Get all articles from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: The result of the database. Can be either of type ``List[Article]`` or ``None``, in case no articles are stored in the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the articles. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Article )) articles_list : List [ Article ] = res . all () if articles_list is not None : return articles_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all articles\" , ) from BaseException","title":"get_articles()"},{"location":"reference/services/articles_service/#src.services.articles_service.ArticlesService.update_article","text":"Update the specified article in the database. Parameters: Name Type Description Default article_id int The ID of the article to update. required article UpdateArticle The information that shall be updated in the article. required db_session AsyncSession The session for the DB. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when updating the article. Returns: Name Type Description ArticleUpdated ArticleUpdated The status that indicates, whether the update was successful. Source code in src/services/articles_service.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 async def update_article ( self , article_id : int , article : UpdateArticle , db_session : AsyncSession ) -> ArticleUpdated : \"\"\"Update the specified article in the database. Args: article_id (int): The ID of the article to update. article (UpdateArticle): The information that shall be updated in the article. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the article. Returns: ArticleUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_article = article . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Article ) . where ( Article . id == article_id ) . values ( ** update_article , updated_at = datetime . now (), ) ) if res . rowcount != 0 : await db_session . commit () return ArticleUpdated ( article_id = article_id , status = \"Article updated\" ) else : return ArticleUpdated ( article_id = article_id , status = \"Article not found\" ) except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the article\" , ) from BaseException","title":"update_article()"},{"location":"reference/services/auth_service/","text":"Auth services. AuthService Provides services for the authentication against the API. Source code in src/services/auth_service.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class AuthService : \"\"\"Provides services for the authentication against the API.\"\"\" async def authenticate_user ( self , mail : str , password : str , db_session : AsyncSession ) -> AuthTokenSchema : \"\"\"Authenticate the user. Conducts the authentication and provide the access tokens, in case the mail and password is correct. Args: mail (str): The mail address of the user. password (str): The password of the user. db_session (AsyncSession): The session for the DB. Raises: HTTPException: Raised in case the mail and / or password is invalid. HTTPException: Raised in case other issues occur during the authentication process. Returns: AuthTokenSchema: The ```Access``` and ```Refresh``` tokens. \"\"\" try : user = await user_service . get_user ( db_session , mail ) if user is None or not user . verify_password ( password ): raise HTTPException ( # noqa: TC301 status_code = status . HTTP_400_BAD_REQUEST , detail = \"Invalid email and / or password\" , ) else : access_tokens = token_service . generate_auth_tokens ( user . email ) return access_tokens except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Ups... Something went wrong. Please try again later\" , ) from BaseException async def refresh_token ( self , token : str ) -> AuthTokenSchema : \"\"\"Refresh the access token. Verifies whether the provided refresh token is valid and provides new auth tokens. Args: token (str): The refresh token to validate. Raises: HTTPException: The provided token is not valid. HTTPException: The refresh token expired. Returns: AuthTokenSchema: The ```Access``` and ```Refresh``` tokens. \"\"\" try : decoded_token = token_service . decode_token ( token ) if decoded_token is None : raise HTTPException ( # noqa: TC301 status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Invalid refresh token\" , ) else : access_tokens = token_service . generate_auth_tokens ( decoded_token . sub ) return access_tokens except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Refresh token expired\" , ) from BaseException authenticate_user ( mail , password , db_session ) async Authenticate the user. Conducts the authentication and provide the access tokens, in case the mail and password is correct. Parameters: Name Type Description Default mail str The mail address of the user. required password str The password of the user. required db_session AsyncSession The session for the DB. required Raises: Type Description HTTPException Raised in case the mail and / or password is invalid. HTTPException Raised in case other issues occur during the authentication process. Returns: Name Type Description AuthTokenSchema AuthTokenSchema The Access and Refresh tokens. Source code in src/services/auth_service.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 async def authenticate_user ( self , mail : str , password : str , db_session : AsyncSession ) -> AuthTokenSchema : \"\"\"Authenticate the user. Conducts the authentication and provide the access tokens, in case the mail and password is correct. Args: mail (str): The mail address of the user. password (str): The password of the user. db_session (AsyncSession): The session for the DB. Raises: HTTPException: Raised in case the mail and / or password is invalid. HTTPException: Raised in case other issues occur during the authentication process. Returns: AuthTokenSchema: The ```Access``` and ```Refresh``` tokens. \"\"\" try : user = await user_service . get_user ( db_session , mail ) if user is None or not user . verify_password ( password ): raise HTTPException ( # noqa: TC301 status_code = status . HTTP_400_BAD_REQUEST , detail = \"Invalid email and / or password\" , ) else : access_tokens = token_service . generate_auth_tokens ( user . email ) return access_tokens except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Ups... Something went wrong. Please try again later\" , ) from BaseException refresh_token ( token ) async Refresh the access token. Verifies whether the provided refresh token is valid and provides new auth tokens. Parameters: Name Type Description Default token str The refresh token to validate. required Raises: Type Description HTTPException The provided token is not valid. HTTPException The refresh token expired. Returns: Name Type Description AuthTokenSchema AuthTokenSchema The Access and Refresh tokens. Source code in src/services/auth_service.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 async def refresh_token ( self , token : str ) -> AuthTokenSchema : \"\"\"Refresh the access token. Verifies whether the provided refresh token is valid and provides new auth tokens. Args: token (str): The refresh token to validate. Raises: HTTPException: The provided token is not valid. HTTPException: The refresh token expired. Returns: AuthTokenSchema: The ```Access``` and ```Refresh``` tokens. \"\"\" try : decoded_token = token_service . decode_token ( token ) if decoded_token is None : raise HTTPException ( # noqa: TC301 status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Invalid refresh token\" , ) else : access_tokens = token_service . generate_auth_tokens ( decoded_token . sub ) return access_tokens except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Refresh token expired\" , ) from BaseException","title":"auth_service"},{"location":"reference/services/auth_service/#src.services.auth_service.AuthService","text":"Provides services for the authentication against the API. Source code in src/services/auth_service.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class AuthService : \"\"\"Provides services for the authentication against the API.\"\"\" async def authenticate_user ( self , mail : str , password : str , db_session : AsyncSession ) -> AuthTokenSchema : \"\"\"Authenticate the user. Conducts the authentication and provide the access tokens, in case the mail and password is correct. Args: mail (str): The mail address of the user. password (str): The password of the user. db_session (AsyncSession): The session for the DB. Raises: HTTPException: Raised in case the mail and / or password is invalid. HTTPException: Raised in case other issues occur during the authentication process. Returns: AuthTokenSchema: The ```Access``` and ```Refresh``` tokens. \"\"\" try : user = await user_service . get_user ( db_session , mail ) if user is None or not user . verify_password ( password ): raise HTTPException ( # noqa: TC301 status_code = status . HTTP_400_BAD_REQUEST , detail = \"Invalid email and / or password\" , ) else : access_tokens = token_service . generate_auth_tokens ( user . email ) return access_tokens except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Ups... Something went wrong. Please try again later\" , ) from BaseException async def refresh_token ( self , token : str ) -> AuthTokenSchema : \"\"\"Refresh the access token. Verifies whether the provided refresh token is valid and provides new auth tokens. Args: token (str): The refresh token to validate. Raises: HTTPException: The provided token is not valid. HTTPException: The refresh token expired. Returns: AuthTokenSchema: The ```Access``` and ```Refresh``` tokens. \"\"\" try : decoded_token = token_service . decode_token ( token ) if decoded_token is None : raise HTTPException ( # noqa: TC301 status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Invalid refresh token\" , ) else : access_tokens = token_service . generate_auth_tokens ( decoded_token . sub ) return access_tokens except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Refresh token expired\" , ) from BaseException","title":"AuthService"},{"location":"reference/services/auth_service/#src.services.auth_service.AuthService.authenticate_user","text":"Authenticate the user. Conducts the authentication and provide the access tokens, in case the mail and password is correct. Parameters: Name Type Description Default mail str The mail address of the user. required password str The password of the user. required db_session AsyncSession The session for the DB. required Raises: Type Description HTTPException Raised in case the mail and / or password is invalid. HTTPException Raised in case other issues occur during the authentication process. Returns: Name Type Description AuthTokenSchema AuthTokenSchema The Access and Refresh tokens. Source code in src/services/auth_service.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 async def authenticate_user ( self , mail : str , password : str , db_session : AsyncSession ) -> AuthTokenSchema : \"\"\"Authenticate the user. Conducts the authentication and provide the access tokens, in case the mail and password is correct. Args: mail (str): The mail address of the user. password (str): The password of the user. db_session (AsyncSession): The session for the DB. Raises: HTTPException: Raised in case the mail and / or password is invalid. HTTPException: Raised in case other issues occur during the authentication process. Returns: AuthTokenSchema: The ```Access``` and ```Refresh``` tokens. \"\"\" try : user = await user_service . get_user ( db_session , mail ) if user is None or not user . verify_password ( password ): raise HTTPException ( # noqa: TC301 status_code = status . HTTP_400_BAD_REQUEST , detail = \"Invalid email and / or password\" , ) else : access_tokens = token_service . generate_auth_tokens ( user . email ) return access_tokens except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Ups... Something went wrong. Please try again later\" , ) from BaseException","title":"authenticate_user()"},{"location":"reference/services/auth_service/#src.services.auth_service.AuthService.refresh_token","text":"Refresh the access token. Verifies whether the provided refresh token is valid and provides new auth tokens. Parameters: Name Type Description Default token str The refresh token to validate. required Raises: Type Description HTTPException The provided token is not valid. HTTPException The refresh token expired. Returns: Name Type Description AuthTokenSchema AuthTokenSchema The Access and Refresh tokens. Source code in src/services/auth_service.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 async def refresh_token ( self , token : str ) -> AuthTokenSchema : \"\"\"Refresh the access token. Verifies whether the provided refresh token is valid and provides new auth tokens. Args: token (str): The refresh token to validate. Raises: HTTPException: The provided token is not valid. HTTPException: The refresh token expired. Returns: AuthTokenSchema: The ```Access``` and ```Refresh``` tokens. \"\"\" try : decoded_token = token_service . decode_token ( token ) if decoded_token is None : raise HTTPException ( # noqa: TC301 status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Invalid refresh token\" , ) else : access_tokens = token_service . generate_auth_tokens ( decoded_token . sub ) return access_tokens except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_401_UNAUTHORIZED , detail = \"Refresh token expired\" , ) from BaseException","title":"refresh_token()"},{"location":"reference/services/projects_service/","text":"Project services. ProjectsService Provides all services to manage projects in the database. Source code in src/services/projects_service.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 class ProjectsService : \"\"\"Provides all services to manage projects in the database.\"\"\" async def get_project ( self , project_id : int , db_session : AsyncSession ) -> Union [ Project , None ]: \"\"\"Get the specified project from the database. Args: project_id (int): The ID of the project to obtain. db_session (AsyncSession): The session for the DB. Raises: HTTPException: Raised in case an error occurs when obtaining the project information. Returns: Union[Project, None]: The result of the database. Can be either of type ``Project`` or ``None``, in case no projects are stored in the DB. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Project ) . filter ( Project . id == project_id )) project : Project = res . scalars () . first () if project is not None : return project else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the project\" , ) from BaseException async def get_projects ( self , skip : int , limit : int , db_session : AsyncSession ) -> Union [ List [ Project ], None ]: \"\"\"Get all projects from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: The result of the database. Can be either of type ``List[Project]`` or ``None``, in case no projects are stored in the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the projects. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Project )) projects_list : List [ Project ] = res . all () if projects_list is not None : return projects_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all projects\" , ) from BaseException async def delete_project ( self , project_id : int , db_session : AsyncSession ) -> ProjectDeleted : \"\"\"Delete the specified project from the database. Args: project_id (int): The ID of the project to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the project. Returns: ProjectDeleted: The information, whether the specified project was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Project ) . where ( Project . id == project_id )) if res . rowcount != 0 : await db_session . commit () return { \"project_id\" : project_id , \"status\" : \"Project deleted\" } else : return { \"project_id\" : project_id , \"status\" : \"Project not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the project\" , ) from BaseException async def create_project ( self , project : Project , db_session : AsyncSession ) -> ProjectCreated : \"\"\"Insert the provided project in the database. Args: project (CreateProject): The project object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the project. Returns: ProjectCreated: The created project including the ID. \"\"\" create_project = project . dict () try : new_project = Project ( ** create_project ) db_session . add ( new_project ) await db_session . commit () return new_project # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the project\" , ) from BaseException async def update_project ( self , project_id : int , project : UpdateProject , db_session : AsyncSession ) -> ProjectUpdated : \"\"\"Update the specified project in the database. Args: project_id (int): The ID of the project to update. project (UpdateProject): The information that shall be updated in the project. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the project. Returns: ProjectUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_project = project . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Project ) . where ( Project . id == project_id ) . values ( ** update_project , ) ) if res . rowcount != 0 : await db_session . commit () return { \"project_id\" : project_id , \"status\" : \"Project updated\" } else : return { \"project_id\" : project_id , \"status\" : \"Project not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the project\" , ) from BaseException create_project ( project , db_session ) async Insert the provided project in the database. Parameters: Name Type Description Default project CreateProject The project object that should be created in the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when creating the project. Returns: Name Type Description ProjectCreated ProjectCreated The created project including the ID. Source code in src/services/projects_service.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 async def create_project ( self , project : Project , db_session : AsyncSession ) -> ProjectCreated : \"\"\"Insert the provided project in the database. Args: project (CreateProject): The project object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the project. Returns: ProjectCreated: The created project including the ID. \"\"\" create_project = project . dict () try : new_project = Project ( ** create_project ) db_session . add ( new_project ) await db_session . commit () return new_project # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the project\" , ) from BaseException delete_project ( project_id , db_session ) async Delete the specified project from the database. Parameters: Name Type Description Default project_id int The ID of the project to delete from the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when deleting the project. Returns: Name Type Description ProjectDeleted ProjectDeleted The information, whether the specified project was successfully deleted. Source code in src/services/projects_service.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 async def delete_project ( self , project_id : int , db_session : AsyncSession ) -> ProjectDeleted : \"\"\"Delete the specified project from the database. Args: project_id (int): The ID of the project to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the project. Returns: ProjectDeleted: The information, whether the specified project was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Project ) . where ( Project . id == project_id )) if res . rowcount != 0 : await db_session . commit () return { \"project_id\" : project_id , \"status\" : \"Project deleted\" } else : return { \"project_id\" : project_id , \"status\" : \"Project not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the project\" , ) from BaseException get_project ( project_id , db_session ) async Get the specified project from the database. Parameters: Name Type Description Default project_id int The ID of the project to obtain. required db_session AsyncSession The session for the DB. required Raises: Type Description HTTPException Raised in case an error occurs when obtaining the project information. Returns: Type Description Union [ Project , None] Union[Project, None]: The result of the database. Can be either of type Project or None , in case no projects are stored in the DB. Source code in src/services/projects_service.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 async def get_project ( self , project_id : int , db_session : AsyncSession ) -> Union [ Project , None ]: \"\"\"Get the specified project from the database. Args: project_id (int): The ID of the project to obtain. db_session (AsyncSession): The session for the DB. Raises: HTTPException: Raised in case an error occurs when obtaining the project information. Returns: Union[Project, None]: The result of the database. Can be either of type ``Project`` or ``None``, in case no projects are stored in the DB. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Project ) . filter ( Project . id == project_id )) project : Project = res . scalars () . first () if project is not None : return project else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the project\" , ) from BaseException get_projects ( skip , limit , db_session ) async Get all projects from the database. Parameters: Name Type Description Default skip int Number of elements to skip from the result set. required limit int Maximum number of elements to return. required db_session AsyncSession The session for the database. required Returns: Type Description Union [ List [ Project ], None] The result of the database. Can be either of type List[Project] or None , in case no projects are stored in the DB. Raises: Type Description HTTPException Is being thrown as soon as an error occurs when obtaining the projects. Source code in src/services/projects_service.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 async def get_projects ( self , skip : int , limit : int , db_session : AsyncSession ) -> Union [ List [ Project ], None ]: \"\"\"Get all projects from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: The result of the database. Can be either of type ``List[Project]`` or ``None``, in case no projects are stored in the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the projects. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Project )) projects_list : List [ Project ] = res . all () if projects_list is not None : return projects_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all projects\" , ) from BaseException update_project ( project_id , project , db_session ) async Update the specified project in the database. Parameters: Name Type Description Default project_id int The ID of the project to update. required project UpdateProject The information that shall be updated in the project. required db_session AsyncSession The session for the DB. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when updating the project. Returns: Name Type Description ProjectUpdated ProjectUpdated The status that indicates, whether the update was successful. Source code in src/services/projects_service.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 async def update_project ( self , project_id : int , project : UpdateProject , db_session : AsyncSession ) -> ProjectUpdated : \"\"\"Update the specified project in the database. Args: project_id (int): The ID of the project to update. project (UpdateProject): The information that shall be updated in the project. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the project. Returns: ProjectUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_project = project . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Project ) . where ( Project . id == project_id ) . values ( ** update_project , ) ) if res . rowcount != 0 : await db_session . commit () return { \"project_id\" : project_id , \"status\" : \"Project updated\" } else : return { \"project_id\" : project_id , \"status\" : \"Project not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the project\" , ) from BaseException","title":"projects_service"},{"location":"reference/services/projects_service/#src.services.projects_service.ProjectsService","text":"Provides all services to manage projects in the database. Source code in src/services/projects_service.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 class ProjectsService : \"\"\"Provides all services to manage projects in the database.\"\"\" async def get_project ( self , project_id : int , db_session : AsyncSession ) -> Union [ Project , None ]: \"\"\"Get the specified project from the database. Args: project_id (int): The ID of the project to obtain. db_session (AsyncSession): The session for the DB. Raises: HTTPException: Raised in case an error occurs when obtaining the project information. Returns: Union[Project, None]: The result of the database. Can be either of type ``Project`` or ``None``, in case no projects are stored in the DB. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Project ) . filter ( Project . id == project_id )) project : Project = res . scalars () . first () if project is not None : return project else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the project\" , ) from BaseException async def get_projects ( self , skip : int , limit : int , db_session : AsyncSession ) -> Union [ List [ Project ], None ]: \"\"\"Get all projects from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: The result of the database. Can be either of type ``List[Project]`` or ``None``, in case no projects are stored in the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the projects. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Project )) projects_list : List [ Project ] = res . all () if projects_list is not None : return projects_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all projects\" , ) from BaseException async def delete_project ( self , project_id : int , db_session : AsyncSession ) -> ProjectDeleted : \"\"\"Delete the specified project from the database. Args: project_id (int): The ID of the project to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the project. Returns: ProjectDeleted: The information, whether the specified project was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Project ) . where ( Project . id == project_id )) if res . rowcount != 0 : await db_session . commit () return { \"project_id\" : project_id , \"status\" : \"Project deleted\" } else : return { \"project_id\" : project_id , \"status\" : \"Project not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the project\" , ) from BaseException async def create_project ( self , project : Project , db_session : AsyncSession ) -> ProjectCreated : \"\"\"Insert the provided project in the database. Args: project (CreateProject): The project object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the project. Returns: ProjectCreated: The created project including the ID. \"\"\" create_project = project . dict () try : new_project = Project ( ** create_project ) db_session . add ( new_project ) await db_session . commit () return new_project # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the project\" , ) from BaseException async def update_project ( self , project_id : int , project : UpdateProject , db_session : AsyncSession ) -> ProjectUpdated : \"\"\"Update the specified project in the database. Args: project_id (int): The ID of the project to update. project (UpdateProject): The information that shall be updated in the project. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the project. Returns: ProjectUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_project = project . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Project ) . where ( Project . id == project_id ) . values ( ** update_project , ) ) if res . rowcount != 0 : await db_session . commit () return { \"project_id\" : project_id , \"status\" : \"Project updated\" } else : return { \"project_id\" : project_id , \"status\" : \"Project not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the project\" , ) from BaseException","title":"ProjectsService"},{"location":"reference/services/projects_service/#src.services.projects_service.ProjectsService.create_project","text":"Insert the provided project in the database. Parameters: Name Type Description Default project CreateProject The project object that should be created in the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when creating the project. Returns: Name Type Description ProjectCreated ProjectCreated The created project including the ID. Source code in src/services/projects_service.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 async def create_project ( self , project : Project , db_session : AsyncSession ) -> ProjectCreated : \"\"\"Insert the provided project in the database. Args: project (CreateProject): The project object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the project. Returns: ProjectCreated: The created project including the ID. \"\"\" create_project = project . dict () try : new_project = Project ( ** create_project ) db_session . add ( new_project ) await db_session . commit () return new_project # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the project\" , ) from BaseException","title":"create_project()"},{"location":"reference/services/projects_service/#src.services.projects_service.ProjectsService.delete_project","text":"Delete the specified project from the database. Parameters: Name Type Description Default project_id int The ID of the project to delete from the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when deleting the project. Returns: Name Type Description ProjectDeleted ProjectDeleted The information, whether the specified project was successfully deleted. Source code in src/services/projects_service.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 async def delete_project ( self , project_id : int , db_session : AsyncSession ) -> ProjectDeleted : \"\"\"Delete the specified project from the database. Args: project_id (int): The ID of the project to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the project. Returns: ProjectDeleted: The information, whether the specified project was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Project ) . where ( Project . id == project_id )) if res . rowcount != 0 : await db_session . commit () return { \"project_id\" : project_id , \"status\" : \"Project deleted\" } else : return { \"project_id\" : project_id , \"status\" : \"Project not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the project\" , ) from BaseException","title":"delete_project()"},{"location":"reference/services/projects_service/#src.services.projects_service.ProjectsService.get_project","text":"Get the specified project from the database. Parameters: Name Type Description Default project_id int The ID of the project to obtain. required db_session AsyncSession The session for the DB. required Raises: Type Description HTTPException Raised in case an error occurs when obtaining the project information. Returns: Type Description Union [ Project , None] Union[Project, None]: The result of the database. Can be either of type Project or None , in case no projects are stored in the DB. Source code in src/services/projects_service.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 async def get_project ( self , project_id : int , db_session : AsyncSession ) -> Union [ Project , None ]: \"\"\"Get the specified project from the database. Args: project_id (int): The ID of the project to obtain. db_session (AsyncSession): The session for the DB. Raises: HTTPException: Raised in case an error occurs when obtaining the project information. Returns: Union[Project, None]: The result of the database. Can be either of type ``Project`` or ``None``, in case no projects are stored in the DB. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Project ) . filter ( Project . id == project_id )) project : Project = res . scalars () . first () if project is not None : return project else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the project\" , ) from BaseException","title":"get_project()"},{"location":"reference/services/projects_service/#src.services.projects_service.ProjectsService.get_projects","text":"Get all projects from the database. Parameters: Name Type Description Default skip int Number of elements to skip from the result set. required limit int Maximum number of elements to return. required db_session AsyncSession The session for the database. required Returns: Type Description Union [ List [ Project ], None] The result of the database. Can be either of type List[Project] or None , in case no projects are stored in the DB. Raises: Type Description HTTPException Is being thrown as soon as an error occurs when obtaining the projects. Source code in src/services/projects_service.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 async def get_projects ( self , skip : int , limit : int , db_session : AsyncSession ) -> Union [ List [ Project ], None ]: \"\"\"Get all projects from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: The result of the database. Can be either of type ``List[Project]`` or ``None``, in case no projects are stored in the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the projects. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Project )) projects_list : List [ Project ] = res . all () if projects_list is not None : return projects_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all projects\" , ) from BaseException","title":"get_projects()"},{"location":"reference/services/projects_service/#src.services.projects_service.ProjectsService.update_project","text":"Update the specified project in the database. Parameters: Name Type Description Default project_id int The ID of the project to update. required project UpdateProject The information that shall be updated in the project. required db_session AsyncSession The session for the DB. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when updating the project. Returns: Name Type Description ProjectUpdated ProjectUpdated The status that indicates, whether the update was successful. Source code in src/services/projects_service.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 async def update_project ( self , project_id : int , project : UpdateProject , db_session : AsyncSession ) -> ProjectUpdated : \"\"\"Update the specified project in the database. Args: project_id (int): The ID of the project to update. project (UpdateProject): The information that shall be updated in the project. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the project. Returns: ProjectUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_project = project . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Project ) . where ( Project . id == project_id ) . values ( ** update_project , ) ) if res . rowcount != 0 : await db_session . commit () return { \"project_id\" : project_id , \"status\" : \"Project updated\" } else : return { \"project_id\" : project_id , \"status\" : \"Project not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the project\" , ) from BaseException","title":"update_project()"},{"location":"reference/services/skills_service/","text":"Skills service. SkillsService Provides all services to manage skills in the database. Source code in src/services/skills_service.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 class SkillsService : \"\"\"Provides all services to manage skills in the database.\"\"\" async def get_skill ( self , skill_id : int , db_session : AsyncSession ) -> SkillDB : \"\"\"Get the specified skill from the database. Args: skill_id: The ID of the skill to obtain from the database. db_session: The session for the database. Returns: SkillDB: The result of the database. Can be either of type ```SkillDB``` or ```None```, in case no row matches the provided ID. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the skill. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Skill ) . filter ( Skill . id == skill_id )) skill : SkillDB = res . scalars () . first () if skill is not None : return skill else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the skill\" , ) from BaseException async def get_skills ( self , skip : int , limit : int , db_session : AsyncSession ) -> List [ Skill ]: \"\"\"Get all skills from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: List[Skill]: The result of the database. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the skills. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Skill )) skill_list : List [ Skill ] = res . all () if skill_list is not None : return skill_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all skills\" , ) from BaseException async def delete_skill ( self , skill_id : int , db_session : AsyncSession ) -> SkillAdjusted : \"\"\"Delete the specified skill from the database. Args: skill_id (int): The ID of the skill to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the skill. Returns: SkillDeleted: The information, whether the specified skill was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Skill ) . where ( Skill . id == skill_id )) if res . rowcount != 0 : await db_session . commit () return { \"skill_id\" : skill_id , \"status\" : \"Skill deleted\" } else : return { \"skill_id\" : skill_id , \"status\" : \"Skill not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the skill\" , ) from BaseException async def create_skill ( self , skill : SkillSchema , db_session : AsyncSession ) -> SkillDB : \"\"\"Insert the provided skill in the database. Args: skill (SkillSchema): The skill object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the skill. Returns: SkillCreated: The created skill including the ID. \"\"\" try : create_skill = skill . dict () new_skill = Skill ( ** create_skill , ) db_session . add ( new_skill ) await db_session . commit () return new_skill # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the skill\" , ) from BaseException async def update_skill ( self , skill_id : int , skill : SkillSchema , db_session : AsyncSession ) -> SkillAdjusted : \"\"\"Update the specified skill in the database. Args: skill_id (int): The ID of the skill to update. skill (SkillSchema): The information that shall be updated in the skill. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the skill. Returns: SkillUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_skill = skill . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Skill ) . where ( Skill . id == skill_id ) . values ( ** update_skill , ) ) if res . rowcount != 0 : await db_session . commit () return SkillAdjusted ( skill_id = skill_id , status = \"Skill updated\" ) else : return SkillAdjusted ( skill_id = skill_id , status = \"Skill not found\" ) except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the skill\" , ) from BaseException create_skill ( skill , db_session ) async Insert the provided skill in the database. Parameters: Name Type Description Default skill SkillSchema The skill object that should be created in the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when creating the skill. Returns: Name Type Description SkillCreated SkillDB The created skill including the ID. Source code in src/services/skills_service.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 async def create_skill ( self , skill : SkillSchema , db_session : AsyncSession ) -> SkillDB : \"\"\"Insert the provided skill in the database. Args: skill (SkillSchema): The skill object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the skill. Returns: SkillCreated: The created skill including the ID. \"\"\" try : create_skill = skill . dict () new_skill = Skill ( ** create_skill , ) db_session . add ( new_skill ) await db_session . commit () return new_skill # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the skill\" , ) from BaseException delete_skill ( skill_id , db_session ) async Delete the specified skill from the database. Parameters: Name Type Description Default skill_id int The ID of the skill to delete from the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when deleting the skill. Returns: Name Type Description SkillDeleted SkillAdjusted The information, whether the specified skill was successfully deleted. Source code in src/services/skills_service.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 async def delete_skill ( self , skill_id : int , db_session : AsyncSession ) -> SkillAdjusted : \"\"\"Delete the specified skill from the database. Args: skill_id (int): The ID of the skill to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the skill. Returns: SkillDeleted: The information, whether the specified skill was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Skill ) . where ( Skill . id == skill_id )) if res . rowcount != 0 : await db_session . commit () return { \"skill_id\" : skill_id , \"status\" : \"Skill deleted\" } else : return { \"skill_id\" : skill_id , \"status\" : \"Skill not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the skill\" , ) from BaseException get_skill ( skill_id , db_session ) async Get the specified skill from the database. Parameters: Name Type Description Default skill_id int The ID of the skill to obtain from the database. required db_session AsyncSession The session for the database. required Returns: Name Type Description SkillDB SkillDB The result of the database. Can be either of type SkillDB or None , in case no row matches the provided ID. Raises: Type Description HTTPException Is being thrown as soon as an error occurs when obtaining the skill. Source code in src/services/skills_service.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 async def get_skill ( self , skill_id : int , db_session : AsyncSession ) -> SkillDB : \"\"\"Get the specified skill from the database. Args: skill_id: The ID of the skill to obtain from the database. db_session: The session for the database. Returns: SkillDB: The result of the database. Can be either of type ```SkillDB``` or ```None```, in case no row matches the provided ID. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the skill. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Skill ) . filter ( Skill . id == skill_id )) skill : SkillDB = res . scalars () . first () if skill is not None : return skill else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the skill\" , ) from BaseException get_skills ( skip , limit , db_session ) async Get all skills from the database. Parameters: Name Type Description Default skip int Number of elements to skip from the result set. required limit int Maximum number of elements to return. required db_session AsyncSession The session for the database. required Returns: Type Description List [ Skill ] List[Skill]: The result of the database. Raises: Type Description HTTPException Is being thrown as soon as an error occurs when obtaining the skills. Source code in src/services/skills_service.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 async def get_skills ( self , skip : int , limit : int , db_session : AsyncSession ) -> List [ Skill ]: \"\"\"Get all skills from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: List[Skill]: The result of the database. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the skills. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Skill )) skill_list : List [ Skill ] = res . all () if skill_list is not None : return skill_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all skills\" , ) from BaseException update_skill ( skill_id , skill , db_session ) async Update the specified skill in the database. Parameters: Name Type Description Default skill_id int The ID of the skill to update. required skill SkillSchema The information that shall be updated in the skill. required db_session AsyncSession The session for the DB. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when updating the skill. Returns: Name Type Description SkillUpdated SkillAdjusted The status that indicates, whether the update was successful. Source code in src/services/skills_service.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 async def update_skill ( self , skill_id : int , skill : SkillSchema , db_session : AsyncSession ) -> SkillAdjusted : \"\"\"Update the specified skill in the database. Args: skill_id (int): The ID of the skill to update. skill (SkillSchema): The information that shall be updated in the skill. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the skill. Returns: SkillUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_skill = skill . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Skill ) . where ( Skill . id == skill_id ) . values ( ** update_skill , ) ) if res . rowcount != 0 : await db_session . commit () return SkillAdjusted ( skill_id = skill_id , status = \"Skill updated\" ) else : return SkillAdjusted ( skill_id = skill_id , status = \"Skill not found\" ) except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the skill\" , ) from BaseException","title":"skills_service"},{"location":"reference/services/skills_service/#src.services.skills_service.SkillsService","text":"Provides all services to manage skills in the database. Source code in src/services/skills_service.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 class SkillsService : \"\"\"Provides all services to manage skills in the database.\"\"\" async def get_skill ( self , skill_id : int , db_session : AsyncSession ) -> SkillDB : \"\"\"Get the specified skill from the database. Args: skill_id: The ID of the skill to obtain from the database. db_session: The session for the database. Returns: SkillDB: The result of the database. Can be either of type ```SkillDB``` or ```None```, in case no row matches the provided ID. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the skill. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Skill ) . filter ( Skill . id == skill_id )) skill : SkillDB = res . scalars () . first () if skill is not None : return skill else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the skill\" , ) from BaseException async def get_skills ( self , skip : int , limit : int , db_session : AsyncSession ) -> List [ Skill ]: \"\"\"Get all skills from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: List[Skill]: The result of the database. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the skills. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Skill )) skill_list : List [ Skill ] = res . all () if skill_list is not None : return skill_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all skills\" , ) from BaseException async def delete_skill ( self , skill_id : int , db_session : AsyncSession ) -> SkillAdjusted : \"\"\"Delete the specified skill from the database. Args: skill_id (int): The ID of the skill to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the skill. Returns: SkillDeleted: The information, whether the specified skill was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Skill ) . where ( Skill . id == skill_id )) if res . rowcount != 0 : await db_session . commit () return { \"skill_id\" : skill_id , \"status\" : \"Skill deleted\" } else : return { \"skill_id\" : skill_id , \"status\" : \"Skill not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the skill\" , ) from BaseException async def create_skill ( self , skill : SkillSchema , db_session : AsyncSession ) -> SkillDB : \"\"\"Insert the provided skill in the database. Args: skill (SkillSchema): The skill object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the skill. Returns: SkillCreated: The created skill including the ID. \"\"\" try : create_skill = skill . dict () new_skill = Skill ( ** create_skill , ) db_session . add ( new_skill ) await db_session . commit () return new_skill # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the skill\" , ) from BaseException async def update_skill ( self , skill_id : int , skill : SkillSchema , db_session : AsyncSession ) -> SkillAdjusted : \"\"\"Update the specified skill in the database. Args: skill_id (int): The ID of the skill to update. skill (SkillSchema): The information that shall be updated in the skill. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the skill. Returns: SkillUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_skill = skill . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Skill ) . where ( Skill . id == skill_id ) . values ( ** update_skill , ) ) if res . rowcount != 0 : await db_session . commit () return SkillAdjusted ( skill_id = skill_id , status = \"Skill updated\" ) else : return SkillAdjusted ( skill_id = skill_id , status = \"Skill not found\" ) except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the skill\" , ) from BaseException","title":"SkillsService"},{"location":"reference/services/skills_service/#src.services.skills_service.SkillsService.create_skill","text":"Insert the provided skill in the database. Parameters: Name Type Description Default skill SkillSchema The skill object that should be created in the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when creating the skill. Returns: Name Type Description SkillCreated SkillDB The created skill including the ID. Source code in src/services/skills_service.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 async def create_skill ( self , skill : SkillSchema , db_session : AsyncSession ) -> SkillDB : \"\"\"Insert the provided skill in the database. Args: skill (SkillSchema): The skill object that should be created in the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when creating the skill. Returns: SkillCreated: The created skill including the ID. \"\"\" try : create_skill = skill . dict () new_skill = Skill ( ** create_skill , ) db_session . add ( new_skill ) await db_session . commit () return new_skill # noqa: TC300 except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error creating the skill\" , ) from BaseException","title":"create_skill()"},{"location":"reference/services/skills_service/#src.services.skills_service.SkillsService.delete_skill","text":"Delete the specified skill from the database. Parameters: Name Type Description Default skill_id int The ID of the skill to delete from the database. required db_session AsyncSession The session for the database. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when deleting the skill. Returns: Name Type Description SkillDeleted SkillAdjusted The information, whether the specified skill was successfully deleted. Source code in src/services/skills_service.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 async def delete_skill ( self , skill_id : int , db_session : AsyncSession ) -> SkillAdjusted : \"\"\"Delete the specified skill from the database. Args: skill_id (int): The ID of the skill to delete from the database. db_session (AsyncSession): The session for the database. Raises: HTTPException: Is being thrown as soon as an error occurs when deleting the skill. Returns: SkillDeleted: The information, whether the specified skill was successfully deleted. \"\"\" try : res : AsyncSession = await db_session . execute ( delete ( Skill ) . where ( Skill . id == skill_id )) if res . rowcount != 0 : await db_session . commit () return { \"skill_id\" : skill_id , \"status\" : \"Skill deleted\" } else : return { \"skill_id\" : skill_id , \"status\" : \"Skill not found\" } except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error deleting the skill\" , ) from BaseException","title":"delete_skill()"},{"location":"reference/services/skills_service/#src.services.skills_service.SkillsService.get_skill","text":"Get the specified skill from the database. Parameters: Name Type Description Default skill_id int The ID of the skill to obtain from the database. required db_session AsyncSession The session for the database. required Returns: Name Type Description SkillDB SkillDB The result of the database. Can be either of type SkillDB or None , in case no row matches the provided ID. Raises: Type Description HTTPException Is being thrown as soon as an error occurs when obtaining the skill. Source code in src/services/skills_service.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 async def get_skill ( self , skill_id : int , db_session : AsyncSession ) -> SkillDB : \"\"\"Get the specified skill from the database. Args: skill_id: The ID of the skill to obtain from the database. db_session: The session for the database. Returns: SkillDB: The result of the database. Can be either of type ```SkillDB``` or ```None```, in case no row matches the provided ID. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the skill. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( Skill ) . filter ( Skill . id == skill_id )) skill : SkillDB = res . scalars () . first () if skill is not None : return skill else : return None except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining the skill\" , ) from BaseException","title":"get_skill()"},{"location":"reference/services/skills_service/#src.services.skills_service.SkillsService.get_skills","text":"Get all skills from the database. Parameters: Name Type Description Default skip int Number of elements to skip from the result set. required limit int Maximum number of elements to return. required db_session AsyncSession The session for the database. required Returns: Type Description List [ Skill ] List[Skill]: The result of the database. Raises: Type Description HTTPException Is being thrown as soon as an error occurs when obtaining the skills. Source code in src/services/skills_service.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 async def get_skills ( self , skip : int , limit : int , db_session : AsyncSession ) -> List [ Skill ]: \"\"\"Get all skills from the database. Args: skip: Number of elements to skip from the result set. limit: Maximum number of elements to return. db_session: The session for the database. Returns: List[Skill]: The result of the database. Raises: HTTPException: Is being thrown as soon as an error occurs when obtaining the skills. \"\"\" try : res : AsyncResult = await db_session . scalars ( select ( Skill )) skill_list : List [ Skill ] = res . all () if skill_list is not None : return skill_list [ skip : skip + limit ] except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error obtaining all skills\" , ) from BaseException","title":"get_skills()"},{"location":"reference/services/skills_service/#src.services.skills_service.SkillsService.update_skill","text":"Update the specified skill in the database. Parameters: Name Type Description Default skill_id int The ID of the skill to update. required skill SkillSchema The information that shall be updated in the skill. required db_session AsyncSession The session for the DB. required Raises: Type Description HTTPException Is being thrown as soon as an error occurs when updating the skill. Returns: Name Type Description SkillUpdated SkillAdjusted The status that indicates, whether the update was successful. Source code in src/services/skills_service.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 async def update_skill ( self , skill_id : int , skill : SkillSchema , db_session : AsyncSession ) -> SkillAdjusted : \"\"\"Update the specified skill in the database. Args: skill_id (int): The ID of the skill to update. skill (SkillSchema): The information that shall be updated in the skill. db_session (AsyncSession):The session for the DB. Raises: HTTPException: Is being thrown as soon as an error occurs when updating the skill. Returns: SkillUpdated: The status that indicates, whether the update was successful. \"\"\" try : update_skill = skill . dict ( exclude_unset = True ) res : AsyncSession = await db_session . execute ( update ( Skill ) . where ( Skill . id == skill_id ) . values ( ** update_skill , ) ) if res . rowcount != 0 : await db_session . commit () return SkillAdjusted ( skill_id = skill_id , status = \"Skill updated\" ) else : return SkillAdjusted ( skill_id = skill_id , status = \"Skill not found\" ) except BaseException : raise HTTPException ( status . HTTP_500_INTERNAL_SERVER_ERROR , \"Error updating the skill\" , ) from BaseException","title":"update_skill()"},{"location":"reference/services/token_service/","text":"Token services. TokenService Provides services for generating the auth tokens. Source code in src/services/token_service.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class TokenService : \"\"\"Provides services for generating the auth tokens.\"\"\" def __generate_token ( self , user_id : str , expires_in : int , type : TokenTypes , secret : str = settings . JWT_SECRET_KEY , ) -> str : \"\"\"Generate a new JWT token. Args: user_id (str): The mail address of the user to use as a ```sub``` in the token. expires_in (int): The UNIX timestamp indicating the expire time of the token. type (TokenTypes): The type of token. secret (str, optional): The algorithm to use for encoding the token. Returns: str: An encoded JWT token. \"\"\" payload = { \"sub\" : user_id , \"iat\" : int ( datetime . now ( ZoneInfo ( \"Europe/Amsterdam\" )) . timestamp ()), \"exp\" : expires_in , \"type\" : type , } return jwt . encode ( payload , secret , algorithm = settings . ALGORITHM ) # type: ignore[no-any-return] def generate_auth_tokens ( self , user_id : str ) -> AuthToken : \"\"\"Generate the access and refresh tokens. Args: user_id (str): The mail address of the user that will be used as a ```sub``` in the token. Returns: AuthToken: The auth object containing an ```access``` and ```refresh```token. \"\"\" access_token_expire = datetime . now () + timedelta ( minutes = settings . ACCESS_TOKEN_EXPIRE_MINUTES ) refresh_token_expire = datetime . now () + timedelta ( minutes = settings . REFRESH_TOKEN_EXPIRE_MINUTES ) access_token = self . __generate_token ( user_id , int ( access_token_expire . timestamp ()), TokenTypes . ACCESS_TOKEN ) refresh_token = self . __generate_token ( user_id , int ( refresh_token_expire . timestamp ()), TokenTypes . REFRESH_TOKEN , settings . JWT_REFRESH_SECRET_KEY , ) auth_token = AuthToken ( __root__ = { TokenTypes . ACCESS_TOKEN : Token ( token = access_token , expires = access_token_expire ), TokenTypes . REFRESH_TOKEN . value : Token ( token = refresh_token , expires = refresh_token_expire ), } ) return auth_token . dict ()[ \"__root__\" ] def decode_token ( self , token : str ) -> TokenPayload : \"\"\"Decode the provided JWT token and returns it. Args: token (str): The JWT token that shall be validated and encoded. Raises: Exception: General exception that needs to be handled from the calling function. Returns: TokenPayload: The decoded JWT token. \"\"\" try : token_payload = jwt . decode ( token , settings . JWT_SECRET_KEY , settings . ALGORITHM ) return TokenPayload ( ** token_payload ) # noqa: TC300 except ExpiredSignatureError : raise Exception () from ExpiredSignatureError # noqa: TC002 __generate_token ( user_id , expires_in , type , secret = settings . JWT_SECRET_KEY ) Generate a new JWT token. Parameters: Name Type Description Default user_id str The mail address of the user to use as a sub in the token. required expires_in int The UNIX timestamp indicating the expire time of the token. required type TokenTypes The type of token. required secret str The algorithm to use for encoding the token. settings.JWT_SECRET_KEY Returns: Name Type Description str str An encoded JWT token. Source code in src/services/token_service.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __generate_token ( self , user_id : str , expires_in : int , type : TokenTypes , secret : str = settings . JWT_SECRET_KEY , ) -> str : \"\"\"Generate a new JWT token. Args: user_id (str): The mail address of the user to use as a ```sub``` in the token. expires_in (int): The UNIX timestamp indicating the expire time of the token. type (TokenTypes): The type of token. secret (str, optional): The algorithm to use for encoding the token. Returns: str: An encoded JWT token. \"\"\" payload = { \"sub\" : user_id , \"iat\" : int ( datetime . now ( ZoneInfo ( \"Europe/Amsterdam\" )) . timestamp ()), \"exp\" : expires_in , \"type\" : type , } return jwt . encode ( payload , secret , algorithm = settings . ALGORITHM ) # type: ignore[no-any-return] decode_token ( token ) Decode the provided JWT token and returns it. Parameters: Name Type Description Default token str The JWT token that shall be validated and encoded. required Raises: Type Description Exception General exception that needs to be handled from the calling function. Returns: Name Type Description TokenPayload TokenPayload The decoded JWT token. Source code in src/services/token_service.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def decode_token ( self , token : str ) -> TokenPayload : \"\"\"Decode the provided JWT token and returns it. Args: token (str): The JWT token that shall be validated and encoded. Raises: Exception: General exception that needs to be handled from the calling function. Returns: TokenPayload: The decoded JWT token. \"\"\" try : token_payload = jwt . decode ( token , settings . JWT_SECRET_KEY , settings . ALGORITHM ) return TokenPayload ( ** token_payload ) # noqa: TC300 except ExpiredSignatureError : raise Exception () from ExpiredSignatureError # noqa: TC002 generate_auth_tokens ( user_id ) Generate the access and refresh tokens. Parameters: Name Type Description Default user_id str The mail address of the user that will be used as a sub in the token. required Returns: Name Type Description AuthToken AuthToken The auth object containing an access and refresh token. Source code in src/services/token_service.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def generate_auth_tokens ( self , user_id : str ) -> AuthToken : \"\"\"Generate the access and refresh tokens. Args: user_id (str): The mail address of the user that will be used as a ```sub``` in the token. Returns: AuthToken: The auth object containing an ```access``` and ```refresh```token. \"\"\" access_token_expire = datetime . now () + timedelta ( minutes = settings . ACCESS_TOKEN_EXPIRE_MINUTES ) refresh_token_expire = datetime . now () + timedelta ( minutes = settings . REFRESH_TOKEN_EXPIRE_MINUTES ) access_token = self . __generate_token ( user_id , int ( access_token_expire . timestamp ()), TokenTypes . ACCESS_TOKEN ) refresh_token = self . __generate_token ( user_id , int ( refresh_token_expire . timestamp ()), TokenTypes . REFRESH_TOKEN , settings . JWT_REFRESH_SECRET_KEY , ) auth_token = AuthToken ( __root__ = { TokenTypes . ACCESS_TOKEN : Token ( token = access_token , expires = access_token_expire ), TokenTypes . REFRESH_TOKEN . value : Token ( token = refresh_token , expires = refresh_token_expire ), } ) return auth_token . dict ()[ \"__root__\" ]","title":"token_service"},{"location":"reference/services/token_service/#src.services.token_service.TokenService","text":"Provides services for generating the auth tokens. Source code in src/services/token_service.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class TokenService : \"\"\"Provides services for generating the auth tokens.\"\"\" def __generate_token ( self , user_id : str , expires_in : int , type : TokenTypes , secret : str = settings . JWT_SECRET_KEY , ) -> str : \"\"\"Generate a new JWT token. Args: user_id (str): The mail address of the user to use as a ```sub``` in the token. expires_in (int): The UNIX timestamp indicating the expire time of the token. type (TokenTypes): The type of token. secret (str, optional): The algorithm to use for encoding the token. Returns: str: An encoded JWT token. \"\"\" payload = { \"sub\" : user_id , \"iat\" : int ( datetime . now ( ZoneInfo ( \"Europe/Amsterdam\" )) . timestamp ()), \"exp\" : expires_in , \"type\" : type , } return jwt . encode ( payload , secret , algorithm = settings . ALGORITHM ) # type: ignore[no-any-return] def generate_auth_tokens ( self , user_id : str ) -> AuthToken : \"\"\"Generate the access and refresh tokens. Args: user_id (str): The mail address of the user that will be used as a ```sub``` in the token. Returns: AuthToken: The auth object containing an ```access``` and ```refresh```token. \"\"\" access_token_expire = datetime . now () + timedelta ( minutes = settings . ACCESS_TOKEN_EXPIRE_MINUTES ) refresh_token_expire = datetime . now () + timedelta ( minutes = settings . REFRESH_TOKEN_EXPIRE_MINUTES ) access_token = self . __generate_token ( user_id , int ( access_token_expire . timestamp ()), TokenTypes . ACCESS_TOKEN ) refresh_token = self . __generate_token ( user_id , int ( refresh_token_expire . timestamp ()), TokenTypes . REFRESH_TOKEN , settings . JWT_REFRESH_SECRET_KEY , ) auth_token = AuthToken ( __root__ = { TokenTypes . ACCESS_TOKEN : Token ( token = access_token , expires = access_token_expire ), TokenTypes . REFRESH_TOKEN . value : Token ( token = refresh_token , expires = refresh_token_expire ), } ) return auth_token . dict ()[ \"__root__\" ] def decode_token ( self , token : str ) -> TokenPayload : \"\"\"Decode the provided JWT token and returns it. Args: token (str): The JWT token that shall be validated and encoded. Raises: Exception: General exception that needs to be handled from the calling function. Returns: TokenPayload: The decoded JWT token. \"\"\" try : token_payload = jwt . decode ( token , settings . JWT_SECRET_KEY , settings . ALGORITHM ) return TokenPayload ( ** token_payload ) # noqa: TC300 except ExpiredSignatureError : raise Exception () from ExpiredSignatureError # noqa: TC002","title":"TokenService"},{"location":"reference/services/token_service/#src.services.token_service.TokenService.__generate_token","text":"Generate a new JWT token. Parameters: Name Type Description Default user_id str The mail address of the user to use as a sub in the token. required expires_in int The UNIX timestamp indicating the expire time of the token. required type TokenTypes The type of token. required secret str The algorithm to use for encoding the token. settings.JWT_SECRET_KEY Returns: Name Type Description str str An encoded JWT token. Source code in src/services/token_service.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __generate_token ( self , user_id : str , expires_in : int , type : TokenTypes , secret : str = settings . JWT_SECRET_KEY , ) -> str : \"\"\"Generate a new JWT token. Args: user_id (str): The mail address of the user to use as a ```sub``` in the token. expires_in (int): The UNIX timestamp indicating the expire time of the token. type (TokenTypes): The type of token. secret (str, optional): The algorithm to use for encoding the token. Returns: str: An encoded JWT token. \"\"\" payload = { \"sub\" : user_id , \"iat\" : int ( datetime . now ( ZoneInfo ( \"Europe/Amsterdam\" )) . timestamp ()), \"exp\" : expires_in , \"type\" : type , } return jwt . encode ( payload , secret , algorithm = settings . ALGORITHM ) # type: ignore[no-any-return]","title":"__generate_token()"},{"location":"reference/services/token_service/#src.services.token_service.TokenService.decode_token","text":"Decode the provided JWT token and returns it. Parameters: Name Type Description Default token str The JWT token that shall be validated and encoded. required Raises: Type Description Exception General exception that needs to be handled from the calling function. Returns: Name Type Description TokenPayload TokenPayload The decoded JWT token. Source code in src/services/token_service.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def decode_token ( self , token : str ) -> TokenPayload : \"\"\"Decode the provided JWT token and returns it. Args: token (str): The JWT token that shall be validated and encoded. Raises: Exception: General exception that needs to be handled from the calling function. Returns: TokenPayload: The decoded JWT token. \"\"\" try : token_payload = jwt . decode ( token , settings . JWT_SECRET_KEY , settings . ALGORITHM ) return TokenPayload ( ** token_payload ) # noqa: TC300 except ExpiredSignatureError : raise Exception () from ExpiredSignatureError # noqa: TC002","title":"decode_token()"},{"location":"reference/services/token_service/#src.services.token_service.TokenService.generate_auth_tokens","text":"Generate the access and refresh tokens. Parameters: Name Type Description Default user_id str The mail address of the user that will be used as a sub in the token. required Returns: Name Type Description AuthToken AuthToken The auth object containing an access and refresh token. Source code in src/services/token_service.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def generate_auth_tokens ( self , user_id : str ) -> AuthToken : \"\"\"Generate the access and refresh tokens. Args: user_id (str): The mail address of the user that will be used as a ```sub``` in the token. Returns: AuthToken: The auth object containing an ```access``` and ```refresh```token. \"\"\" access_token_expire = datetime . now () + timedelta ( minutes = settings . ACCESS_TOKEN_EXPIRE_MINUTES ) refresh_token_expire = datetime . now () + timedelta ( minutes = settings . REFRESH_TOKEN_EXPIRE_MINUTES ) access_token = self . __generate_token ( user_id , int ( access_token_expire . timestamp ()), TokenTypes . ACCESS_TOKEN ) refresh_token = self . __generate_token ( user_id , int ( refresh_token_expire . timestamp ()), TokenTypes . REFRESH_TOKEN , settings . JWT_REFRESH_SECRET_KEY , ) auth_token = AuthToken ( __root__ = { TokenTypes . ACCESS_TOKEN : Token ( token = access_token , expires = access_token_expire ), TokenTypes . REFRESH_TOKEN . value : Token ( token = refresh_token , expires = refresh_token_expire ), } ) return auth_token . dict ()[ \"__root__\" ]","title":"generate_auth_tokens()"},{"location":"reference/services/user_service/","text":"User services. UserService Provides all user related services. Source code in src/services/user_service.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class UserService : \"\"\"Provides all user related services.\"\"\" async def create_new_user ( self , db_session : Session , mail : str , password : str ) -> UserCreated : \"\"\"Create a new user in the database. Args: db_session (Session): The session for the DB. mail (str): The mail address of the new user. password (str): The password of the new user. Raises: HTTPException: Raised, in case the mail is already taken. HTTPException: Raised, in case any other errors occur during the creation. Returns: UserCreated: The status, that the user has been successfully created. \"\"\" try : user_in_db = await self . get_user ( db_session , mail ) if user_in_db is None : new_user = User ( email = mail , hash_password = password ) db_session . add ( new_user ) await db_session . commit () # type: ignore[func-returns-value] return { \"email\" : mail , \"status\" : \"User successfully created\" } raise HTTPException ( # noqa: TC301 status_code = status . HTTP_400_BAD_REQUEST , detail = \"Mail already used. Please provide another one.\" , ) except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error creating the user in the DB\" , ) from BaseException async def get_user ( self , db_session : Session , mail : str ) -> Union [ User , None ]: \"\"\"Get the user from the DB. Returns the matched user based on the provided ID. Args: db_session (Session): The session for the DB. mail (str): The mail of the user to obtain. Raises: HTTPException: Raised, in case there is an error when obtaining the user. Returns: Union[User, None]: Can be either the user information ```User``` in case it is available or ```None```. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( User ) . where ( User . email == mail )) user : User = res . scalars () . first () if user is not None : return user else : return None except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error obtaining the specified user from the database\" , ) from BaseException async def delete_user ( self , db_session : Session , mail : str ) -> UserDeleted : \"\"\"Delete the specified user. Args: db_session (Session): The session for the db. mail (str): The mail address of the user to delete. Raises: HTTPException: Raised, in case there is an error when deleting the user. Returns: UserDeleted: The status indicating, whether the deletion was successful. \"\"\" try : res : AsyncResult = await db_session . execute ( delete ( User ) . where ( User . email == mail )) if res . rowcount != 0 : await db_session . commit () # type: ignore[func-returns-value] return { \"email\" : mail , \"status\" : \"User deleted\" } else : return { \"email\" : mail , \"status\" : \"User not found\" } except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error deleting the specified user in the database\" , ) from BaseException create_new_user ( db_session , mail , password ) async Create a new user in the database. Parameters: Name Type Description Default db_session Session The session for the DB. required mail str The mail address of the new user. required password str The password of the new user. required Raises: Type Description HTTPException Raised, in case the mail is already taken. HTTPException Raised, in case any other errors occur during the creation. Returns: Name Type Description UserCreated UserCreated The status, that the user has been successfully created. Source code in src/services/user_service.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 async def create_new_user ( self , db_session : Session , mail : str , password : str ) -> UserCreated : \"\"\"Create a new user in the database. Args: db_session (Session): The session for the DB. mail (str): The mail address of the new user. password (str): The password of the new user. Raises: HTTPException: Raised, in case the mail is already taken. HTTPException: Raised, in case any other errors occur during the creation. Returns: UserCreated: The status, that the user has been successfully created. \"\"\" try : user_in_db = await self . get_user ( db_session , mail ) if user_in_db is None : new_user = User ( email = mail , hash_password = password ) db_session . add ( new_user ) await db_session . commit () # type: ignore[func-returns-value] return { \"email\" : mail , \"status\" : \"User successfully created\" } raise HTTPException ( # noqa: TC301 status_code = status . HTTP_400_BAD_REQUEST , detail = \"Mail already used. Please provide another one.\" , ) except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error creating the user in the DB\" , ) from BaseException delete_user ( db_session , mail ) async Delete the specified user. Parameters: Name Type Description Default db_session Session The session for the db. required mail str The mail address of the user to delete. required Raises: Type Description HTTPException Raised, in case there is an error when deleting the user. Returns: Name Type Description UserDeleted UserDeleted The status indicating, whether the deletion was successful. Source code in src/services/user_service.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 async def delete_user ( self , db_session : Session , mail : str ) -> UserDeleted : \"\"\"Delete the specified user. Args: db_session (Session): The session for the db. mail (str): The mail address of the user to delete. Raises: HTTPException: Raised, in case there is an error when deleting the user. Returns: UserDeleted: The status indicating, whether the deletion was successful. \"\"\" try : res : AsyncResult = await db_session . execute ( delete ( User ) . where ( User . email == mail )) if res . rowcount != 0 : await db_session . commit () # type: ignore[func-returns-value] return { \"email\" : mail , \"status\" : \"User deleted\" } else : return { \"email\" : mail , \"status\" : \"User not found\" } except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error deleting the specified user in the database\" , ) from BaseException get_user ( db_session , mail ) async Get the user from the DB. Returns the matched user based on the provided ID. Parameters: Name Type Description Default db_session Session The session for the DB. required mail str The mail of the user to obtain. required Raises: Type Description HTTPException Raised, in case there is an error when obtaining the user. Returns: Type Description Union [ User , None] Union[User, None]: Can be either the user information User in case it is Union [ User , None] available or None . Source code in src/services/user_service.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 async def get_user ( self , db_session : Session , mail : str ) -> Union [ User , None ]: \"\"\"Get the user from the DB. Returns the matched user based on the provided ID. Args: db_session (Session): The session for the DB. mail (str): The mail of the user to obtain. Raises: HTTPException: Raised, in case there is an error when obtaining the user. Returns: Union[User, None]: Can be either the user information ```User``` in case it is available or ```None```. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( User ) . where ( User . email == mail )) user : User = res . scalars () . first () if user is not None : return user else : return None except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error obtaining the specified user from the database\" , ) from BaseException","title":"user_service"},{"location":"reference/services/user_service/#src.services.user_service.UserService","text":"Provides all user related services. Source code in src/services/user_service.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class UserService : \"\"\"Provides all user related services.\"\"\" async def create_new_user ( self , db_session : Session , mail : str , password : str ) -> UserCreated : \"\"\"Create a new user in the database. Args: db_session (Session): The session for the DB. mail (str): The mail address of the new user. password (str): The password of the new user. Raises: HTTPException: Raised, in case the mail is already taken. HTTPException: Raised, in case any other errors occur during the creation. Returns: UserCreated: The status, that the user has been successfully created. \"\"\" try : user_in_db = await self . get_user ( db_session , mail ) if user_in_db is None : new_user = User ( email = mail , hash_password = password ) db_session . add ( new_user ) await db_session . commit () # type: ignore[func-returns-value] return { \"email\" : mail , \"status\" : \"User successfully created\" } raise HTTPException ( # noqa: TC301 status_code = status . HTTP_400_BAD_REQUEST , detail = \"Mail already used. Please provide another one.\" , ) except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error creating the user in the DB\" , ) from BaseException async def get_user ( self , db_session : Session , mail : str ) -> Union [ User , None ]: \"\"\"Get the user from the DB. Returns the matched user based on the provided ID. Args: db_session (Session): The session for the DB. mail (str): The mail of the user to obtain. Raises: HTTPException: Raised, in case there is an error when obtaining the user. Returns: Union[User, None]: Can be either the user information ```User``` in case it is available or ```None```. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( User ) . where ( User . email == mail )) user : User = res . scalars () . first () if user is not None : return user else : return None except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error obtaining the specified user from the database\" , ) from BaseException async def delete_user ( self , db_session : Session , mail : str ) -> UserDeleted : \"\"\"Delete the specified user. Args: db_session (Session): The session for the db. mail (str): The mail address of the user to delete. Raises: HTTPException: Raised, in case there is an error when deleting the user. Returns: UserDeleted: The status indicating, whether the deletion was successful. \"\"\" try : res : AsyncResult = await db_session . execute ( delete ( User ) . where ( User . email == mail )) if res . rowcount != 0 : await db_session . commit () # type: ignore[func-returns-value] return { \"email\" : mail , \"status\" : \"User deleted\" } else : return { \"email\" : mail , \"status\" : \"User not found\" } except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error deleting the specified user in the database\" , ) from BaseException","title":"UserService"},{"location":"reference/services/user_service/#src.services.user_service.UserService.create_new_user","text":"Create a new user in the database. Parameters: Name Type Description Default db_session Session The session for the DB. required mail str The mail address of the new user. required password str The password of the new user. required Raises: Type Description HTTPException Raised, in case the mail is already taken. HTTPException Raised, in case any other errors occur during the creation. Returns: Name Type Description UserCreated UserCreated The status, that the user has been successfully created. Source code in src/services/user_service.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 async def create_new_user ( self , db_session : Session , mail : str , password : str ) -> UserCreated : \"\"\"Create a new user in the database. Args: db_session (Session): The session for the DB. mail (str): The mail address of the new user. password (str): The password of the new user. Raises: HTTPException: Raised, in case the mail is already taken. HTTPException: Raised, in case any other errors occur during the creation. Returns: UserCreated: The status, that the user has been successfully created. \"\"\" try : user_in_db = await self . get_user ( db_session , mail ) if user_in_db is None : new_user = User ( email = mail , hash_password = password ) db_session . add ( new_user ) await db_session . commit () # type: ignore[func-returns-value] return { \"email\" : mail , \"status\" : \"User successfully created\" } raise HTTPException ( # noqa: TC301 status_code = status . HTTP_400_BAD_REQUEST , detail = \"Mail already used. Please provide another one.\" , ) except HTTPException : raise except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error creating the user in the DB\" , ) from BaseException","title":"create_new_user()"},{"location":"reference/services/user_service/#src.services.user_service.UserService.delete_user","text":"Delete the specified user. Parameters: Name Type Description Default db_session Session The session for the db. required mail str The mail address of the user to delete. required Raises: Type Description HTTPException Raised, in case there is an error when deleting the user. Returns: Name Type Description UserDeleted UserDeleted The status indicating, whether the deletion was successful. Source code in src/services/user_service.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 async def delete_user ( self , db_session : Session , mail : str ) -> UserDeleted : \"\"\"Delete the specified user. Args: db_session (Session): The session for the db. mail (str): The mail address of the user to delete. Raises: HTTPException: Raised, in case there is an error when deleting the user. Returns: UserDeleted: The status indicating, whether the deletion was successful. \"\"\" try : res : AsyncResult = await db_session . execute ( delete ( User ) . where ( User . email == mail )) if res . rowcount != 0 : await db_session . commit () # type: ignore[func-returns-value] return { \"email\" : mail , \"status\" : \"User deleted\" } else : return { \"email\" : mail , \"status\" : \"User not found\" } except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error deleting the specified user in the database\" , ) from BaseException","title":"delete_user()"},{"location":"reference/services/user_service/#src.services.user_service.UserService.get_user","text":"Get the user from the DB. Returns the matched user based on the provided ID. Parameters: Name Type Description Default db_session Session The session for the DB. required mail str The mail of the user to obtain. required Raises: Type Description HTTPException Raised, in case there is an error when obtaining the user. Returns: Type Description Union [ User , None] Union[User, None]: Can be either the user information User in case it is Union [ User , None] available or None . Source code in src/services/user_service.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 async def get_user ( self , db_session : Session , mail : str ) -> Union [ User , None ]: \"\"\"Get the user from the DB. Returns the matched user based on the provided ID. Args: db_session (Session): The session for the DB. mail (str): The mail of the user to obtain. Raises: HTTPException: Raised, in case there is an error when obtaining the user. Returns: Union[User, None]: Can be either the user information ```User``` in case it is available or ```None```. \"\"\" try : res : AsyncResult = await db_session . execute ( select ( User ) . where ( User . email == mail )) user : User = res . scalars () . first () if user is not None : return user else : return None except BaseException : raise HTTPException ( status_code = status . HTTP_500_INTERNAL_SERVER_ERROR , detail = \"Error obtaining the specified user from the database\" , ) from BaseException","title":"get_user()"},{"location":"reference/util/","text":"This folder contains utilization scrips that are required to execute the API.","title":"util"},{"location":"reference/util/jwt_authentication/","text":"Functions for handling JWT authentication. JWTAuthentication Bases: HTTPBearer Provides the logic to extract and validate a JWT token. Source code in src/util/jwt_authentication.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class JWTAuthentication ( HTTPBearer ): \"\"\"Provides the logic to extract and validate a JWT token.\"\"\" def __init__ ( self , * , auto_error : bool = True ): \"\"\"Initiate an new instance. Args: auto_error (bool, optional): Flag that indicates, whether to throw an error, in case no token was provided. Defaults to ```True```. \"\"\" super () . __init__ ( auto_error = auto_error ) async def __call__ ( self , request : Request ) -> HTTPAuthorizationCredentials : \"\"\"Validate the credentials in the request. Checks, whether a valid bearer token was provided in the request. Args: request (Request): The current request object, containing all client related information. Raises: HTTPException: No token of scheme type \"Bearer\" provided. HTTPException: Not a valid bearer token provided. HTTPException: No credentials provided. Returns: HTTPAuthorizationCredentials: The validated and valid token. \"\"\" token : Optional [ HTTPAuthorizationCredentials ] = await super () . __call__ ( request ) if token : if token . scheme != \"Bearer\" : raise HTTPException ( status . HTTP_403_FORBIDDEN , \"Not supported authentication scheme\" ) if not self . __verify_token ( token . credentials ): raise HTTPException ( status . HTTP_403_FORBIDDEN , \"Invalid bearer token\" ) return token else : raise HTTPException ( status . HTTP_403_FORBIDDEN , \"No credentials provided\" ) def __verify_token ( self , token : str ) -> bool : \"\"\"Verify the provided token. Verifies the token and checks, whether the decoded token is still valid. Args: token (str): The token that should be validated. Returns: bool: The result, whether the provided token is valid. \"\"\" try : token_payload = token_service . decode_token ( token ) if datetime . fromtimestamp ( token_payload . exp ) > datetime . now (): return True else : return False except BaseException : return False __call__ ( request ) async Validate the credentials in the request. Checks, whether a valid bearer token was provided in the request. Parameters: Name Type Description Default request Request The current request object, containing all client related information. required Raises: Type Description HTTPException No token of scheme type \"Bearer\" provided. HTTPException Not a valid bearer token provided. HTTPException No credentials provided. Returns: Name Type Description HTTPAuthorizationCredentials HTTPAuthorizationCredentials The validated and valid token. Source code in src/util/jwt_authentication.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 async def __call__ ( self , request : Request ) -> HTTPAuthorizationCredentials : \"\"\"Validate the credentials in the request. Checks, whether a valid bearer token was provided in the request. Args: request (Request): The current request object, containing all client related information. Raises: HTTPException: No token of scheme type \"Bearer\" provided. HTTPException: Not a valid bearer token provided. HTTPException: No credentials provided. Returns: HTTPAuthorizationCredentials: The validated and valid token. \"\"\" token : Optional [ HTTPAuthorizationCredentials ] = await super () . __call__ ( request ) if token : if token . scheme != \"Bearer\" : raise HTTPException ( status . HTTP_403_FORBIDDEN , \"Not supported authentication scheme\" ) if not self . __verify_token ( token . credentials ): raise HTTPException ( status . HTTP_403_FORBIDDEN , \"Invalid bearer token\" ) return token else : raise HTTPException ( status . HTTP_403_FORBIDDEN , \"No credentials provided\" ) __init__ ( * , auto_error = True ) Initiate an new instance. Parameters: Name Type Description Default auto_error bool Flag that indicates, whether to throw an error, in case no token was provided. Defaults to True . True Source code in src/util/jwt_authentication.py 14 15 16 17 18 19 20 21 def __init__ ( self , * , auto_error : bool = True ): \"\"\"Initiate an new instance. Args: auto_error (bool, optional): Flag that indicates, whether to throw an error, in case no token was provided. Defaults to ```True```. \"\"\" super () . __init__ ( auto_error = auto_error ) __verify_token ( token ) Verify the provided token. Verifies the token and checks, whether the decoded token is still valid. Parameters: Name Type Description Default token str The token that should be validated. required Returns: Name Type Description bool bool The result, whether the provided token is valid. Source code in src/util/jwt_authentication.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def __verify_token ( self , token : str ) -> bool : \"\"\"Verify the provided token. Verifies the token and checks, whether the decoded token is still valid. Args: token (str): The token that should be validated. Returns: bool: The result, whether the provided token is valid. \"\"\" try : token_payload = token_service . decode_token ( token ) if datetime . fromtimestamp ( token_payload . exp ) > datetime . now (): return True else : return False except BaseException : return False","title":"jwt_authentication"},{"location":"reference/util/jwt_authentication/#src.util.jwt_authentication.JWTAuthentication","text":"Bases: HTTPBearer Provides the logic to extract and validate a JWT token. Source code in src/util/jwt_authentication.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class JWTAuthentication ( HTTPBearer ): \"\"\"Provides the logic to extract and validate a JWT token.\"\"\" def __init__ ( self , * , auto_error : bool = True ): \"\"\"Initiate an new instance. Args: auto_error (bool, optional): Flag that indicates, whether to throw an error, in case no token was provided. Defaults to ```True```. \"\"\" super () . __init__ ( auto_error = auto_error ) async def __call__ ( self , request : Request ) -> HTTPAuthorizationCredentials : \"\"\"Validate the credentials in the request. Checks, whether a valid bearer token was provided in the request. Args: request (Request): The current request object, containing all client related information. Raises: HTTPException: No token of scheme type \"Bearer\" provided. HTTPException: Not a valid bearer token provided. HTTPException: No credentials provided. Returns: HTTPAuthorizationCredentials: The validated and valid token. \"\"\" token : Optional [ HTTPAuthorizationCredentials ] = await super () . __call__ ( request ) if token : if token . scheme != \"Bearer\" : raise HTTPException ( status . HTTP_403_FORBIDDEN , \"Not supported authentication scheme\" ) if not self . __verify_token ( token . credentials ): raise HTTPException ( status . HTTP_403_FORBIDDEN , \"Invalid bearer token\" ) return token else : raise HTTPException ( status . HTTP_403_FORBIDDEN , \"No credentials provided\" ) def __verify_token ( self , token : str ) -> bool : \"\"\"Verify the provided token. Verifies the token and checks, whether the decoded token is still valid. Args: token (str): The token that should be validated. Returns: bool: The result, whether the provided token is valid. \"\"\" try : token_payload = token_service . decode_token ( token ) if datetime . fromtimestamp ( token_payload . exp ) > datetime . now (): return True else : return False except BaseException : return False","title":"JWTAuthentication"},{"location":"reference/util/jwt_authentication/#src.util.jwt_authentication.JWTAuthentication.__call__","text":"Validate the credentials in the request. Checks, whether a valid bearer token was provided in the request. Parameters: Name Type Description Default request Request The current request object, containing all client related information. required Raises: Type Description HTTPException No token of scheme type \"Bearer\" provided. HTTPException Not a valid bearer token provided. HTTPException No credentials provided. Returns: Name Type Description HTTPAuthorizationCredentials HTTPAuthorizationCredentials The validated and valid token. Source code in src/util/jwt_authentication.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 async def __call__ ( self , request : Request ) -> HTTPAuthorizationCredentials : \"\"\"Validate the credentials in the request. Checks, whether a valid bearer token was provided in the request. Args: request (Request): The current request object, containing all client related information. Raises: HTTPException: No token of scheme type \"Bearer\" provided. HTTPException: Not a valid bearer token provided. HTTPException: No credentials provided. Returns: HTTPAuthorizationCredentials: The validated and valid token. \"\"\" token : Optional [ HTTPAuthorizationCredentials ] = await super () . __call__ ( request ) if token : if token . scheme != \"Bearer\" : raise HTTPException ( status . HTTP_403_FORBIDDEN , \"Not supported authentication scheme\" ) if not self . __verify_token ( token . credentials ): raise HTTPException ( status . HTTP_403_FORBIDDEN , \"Invalid bearer token\" ) return token else : raise HTTPException ( status . HTTP_403_FORBIDDEN , \"No credentials provided\" )","title":"__call__()"},{"location":"reference/util/jwt_authentication/#src.util.jwt_authentication.JWTAuthentication.__init__","text":"Initiate an new instance. Parameters: Name Type Description Default auto_error bool Flag that indicates, whether to throw an error, in case no token was provided. Defaults to True . True Source code in src/util/jwt_authentication.py 14 15 16 17 18 19 20 21 def __init__ ( self , * , auto_error : bool = True ): \"\"\"Initiate an new instance. Args: auto_error (bool, optional): Flag that indicates, whether to throw an error, in case no token was provided. Defaults to ```True```. \"\"\" super () . __init__ ( auto_error = auto_error )","title":"__init__()"},{"location":"reference/util/jwt_authentication/#src.util.jwt_authentication.JWTAuthentication.__verify_token","text":"Verify the provided token. Verifies the token and checks, whether the decoded token is still valid. Parameters: Name Type Description Default token str The token that should be validated. required Returns: Name Type Description bool bool The result, whether the provided token is valid. Source code in src/util/jwt_authentication.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def __verify_token ( self , token : str ) -> bool : \"\"\"Verify the provided token. Verifies the token and checks, whether the decoded token is still valid. Args: token (str): The token that should be validated. Returns: bool: The result, whether the provided token is valid. \"\"\" try : token_payload = token_service . decode_token ( token ) if datetime . fromtimestamp ( token_payload . exp ) > datetime . now (): return True else : return False except BaseException : return False","title":"__verify_token()"}]}